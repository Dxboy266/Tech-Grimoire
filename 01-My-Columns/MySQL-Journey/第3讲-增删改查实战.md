# 第3讲:增删改查实战——搞定80%日常需求

> **目标:** 掌握DML核心操作,写出高效SQL

---

## 开篇:增删改查就是你的日常

上一讲咱们把employee表建好了,也插入了几条数据。今天要学的是你以后天天要用的:**增删改查**。

这四个操作占了你日常工作的80%。掌握了它们,MySQL就算入门了。

今天会用大量实战案例带你练习,还会告诉你**踩过的坑**。保证你看完就能上手干活。

---

## 一、INSERT:往表里塞数据

### 基础:单条插入 vs 批量插入

```sql
-- 单条插入
INSERT INTO employee (name, department, salary, hire_date) 
VALUES ('张三', '技术部', 8000, '2023-01-15');

-- 批量插入(推荐,效率高10倍)
INSERT INTO employee (name, department, salary, hire_date) VALUES
('李四', '市场部', 6000, '2023-03-20'),
('王五', '技术部', 9000, '2022-11-10'),
('赵六', '人力部', 7000, '2023-05-01');
```

**为啥批量快?** 单条插入每次要:连接→插入→提交→断开。批量插入只需一次连接,效率差10倍!

> 📸 **截图1:** 批量插入执行结果

### 进阶:处理重复数据

```sql
-- INSERT IGNORE:重复就跳过
INSERT IGNORE INTO employee (id, name, salary) VALUES (1, '张三', 8000);

-- ON DUPLICATE KEY UPDATE:重复就更新
INSERT INTO employee (id, name, salary) VALUES (1, '张三', 9000)
ON DUPLICATE KEY UPDATE salary = 9000;
```

**什么时候用?** 批量导入不确定哪些数据已存在时,用`IGNORE`跳过重复;需要"有则更新、无则插入"时,用`ON DUPLICATE KEY UPDATE`。

---

## 二、SELECT:查数据(重点中的重点)

SELECT是你用得最多的语句,没有之一。

### 基础查询

```sql
-- 查指定字段(别用SELECT *,性能差)
SELECT name, salary FROM employee;

-- 起别名
SELECT name AS 姓名, salary AS 薪资 FROM employee;
```

### WHERE条件查询

```sql
-- 单个条件
SELECT * FROM employee WHERE department = '技术部';

-- 多个条件
SELECT * FROM employee WHERE department = '技术部' AND salary > 8000;

-- 范围查询
SELECT * FROM employee WHERE salary BETWEEN 7000 AND 9000;

-- 列表查询
SELECT * FROM employee WHERE department IN ('技术部', '市场部');

-- 模糊查询(%表示任意字符,_表示单个字符)
SELECT * FROM employee WHERE name LIKE '张%';  -- 姓张的

-- 空值查询
SELECT * FROM employee WHERE department IS NULL;
```

> 📸 **截图2:** 各种WHERE条件查询结果

### 排序、分页、去重

```sql
-- 排序:ASC升序,DESC降序
SELECT * FROM employee ORDER BY salary DESC;

-- 分页:第N页 = LIMIT 每页数量 OFFSET (N-1)*每页数量
SELECT * FROM employee LIMIT 10 OFFSET 20;  -- 第3页

-- 去重
SELECT DISTINCT department FROM employee;
```

**避坑:** OFFSET太大会很慢,千万级数据避免`LIMIT 10 OFFSET 1000000`,第9讲会讲优化方案。

### SELECT完整语法顺序

```sql
SELECT 字段
FROM 表名
WHERE 筛选行
GROUP BY 分组
HAVING 筛选组
ORDER BY 排序
LIMIT 限制数量;
```

**执行顺序:** FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

---

## 三、聚合函数与分组统计

### 五大聚合函数

```sql
SELECT COUNT(*) FROM employee;             -- 统计数量
SELECT SUM(salary) FROM employee;          -- 求和
SELECT AVG(salary) FROM employee;          -- 平均值
SELECT MAX(salary) FROM employee;          -- 最大值
SELECT MIN(salary) FROM employee;          -- 最小值
```

**COUNT怎么选?**
- `COUNT(*)`:统计行数,包括NULL(推荐)
- `COUNT(字段)`:统计字段非NULL的行数(慢一点)
- `COUNT(1)`:和`COUNT(*)`差不多

`COUNT(*)`性能最好,因为只统计行数不读字段。具体原理第5讲《索引》详解。

### GROUP BY分组统计

```sql
-- 统计各部门人数和平均工资
SELECT department, 
       COUNT(*) AS 人数,
       AVG(salary) AS 平均工资
FROM employee
GROUP BY department;
```

> 📸 **截图3:** GROUP BY分组统计结果

### HAVING:筛选分组结果

```sql
-- 统计平均工资>8000的部门
SELECT department, AVG(salary) AS 平均工资
FROM employee
GROUP BY department
HAVING AVG(salary) > 8000;
```

**WHERE vs HAVING:** WHERE筛选行(分组前),HAVING筛选组(分组后)。WHERE不能用聚合函数,HAVING可以。

---

## 四、多表查询:INNER JOIN入门

实际工作中,数据分散在多个表里,需要关联查询。

### 准备部门表

```sql
CREATE TABLE department (
    dept_name VARCHAR(30) PRIMARY KEY,
    location VARCHAR(50)
) DEFAULT CHARSET=utf8mb4;

INSERT INTO department (dept_name, location) VALUES
('技术部', '北京'), ('市场部', '上海'), ('人力部', '深圳');
```

### INNER JOIN:内连接

```sql
-- 查询员工和所在部门的城市
SELECT e.name, e.salary, d.location
FROM employee e
INNER JOIN department d ON e.department = d.dept_name;
```

**语法解释:**
- `FROM employee e`:给表起别名e
- `INNER JOIN department d`:关联部门表d
- `ON e.department = d.dept_name`:关联条件

INNER JOIN只返回两表都匹配上的记录。

> 📸 **截图4:** INNER JOIN执行结果

**其他JOIN:** LEFT JOIN(左表全保留)、RIGHT JOIN(右表全保留),后续课程详细讲。

---

## 五、UPDATE/DELETE:危险操作必加WHERE

### UPDATE修改数据

```sql
-- 单字段修改
UPDATE employee SET salary = 9000 WHERE name = '张三';

-- 多字段修改
UPDATE employee SET salary = 10000, department = '架构部' WHERE name = '王五';

-- ❌ 危险!不加WHERE会改全表
UPDATE employee SET salary = 5000;  -- 全公司工资都变5000
```

**避坑技巧:**
1. 先SELECT确认:`SELECT * FROM employee WHERE name = '张三';`
2. 加LIMIT限制:`UPDATE employee SET salary = 9000 WHERE name = '张三' LIMIT 1;`
3. 开事务测试:`START TRANSACTION;` → 执行UPDATE → `SELECT * 检查` → `ROLLBACK回滚` 或 `COMMIT提交`

### DELETE删除数据

```sql
-- 正确用法:加WHERE
DELETE FROM employee WHERE id = 5;

-- ❌ 超级危险!不加WHERE会删全表
DELETE FROM employee;  -- 所有数据全没
```

**避坑技巧:**
1. 先SELECT确认:`SELECT * FROM employee WHERE id = 5;`
2. 加LIMIT限制:`DELETE FROM employee WHERE id = 5 LIMIT 1;`
3. **用软删除:**加`is_deleted`字段,删除时`UPDATE employee SET is_deleted = 1`,查询时`WHERE is_deleted = 0`

### DELETE vs TRUNCATE vs DROP

| 操作 | 作用 | 能加WHERE | 能回滚 | 速度 |
|------|------|-----------|--------|------|
| DELETE | 删除部分数据 | ✅ | ✅(事务中) | 慢 |
| TRUNCATE | 清空全表 | ❌ | ❌ | 快 |
| DROP | 删表结构+数据 | ❌ | ❌ | 最快 |

**建议:** 删部分数据用DELETE,清空全表用TRUNCATE,删表结构用DROP(慎用)。

---

## 六、常用函数速查

| 分类 | 函数 | 作用 | 示例 |
|------|------|------|------|
| **字符串** | CONCAT | 拼接 | `CONCAT(name, '-', department)` |
| | LENGTH | 长度 | `LENGTH(name)` |
| | SUBSTRING | 截取 | `SUBSTRING(name, 1, 1)` |
| **数字** | ROUND | 四舍五入 | `ROUND(8.567, 2)` → 8.57 |
| | CEIL/FLOOR | 向上/下取整 | `CEIL(8.1)` → 9 |
| **日期** | NOW | 当前时间 | `NOW()` → 2024-01-15 10:30:00 |
| | DATEDIFF | 日期差(天) | `DATEDIFF(NOW(), hire_date)` |
| | DATE_FORMAT | 格式化 | `DATE_FORMAT(hire_date, '%Y年%m月')` |

**实用案例:查入职超过1年的员工**

```sql
SELECT name, DATEDIFF(NOW(), hire_date) AS 入职天数
FROM employee
WHERE DATEDIFF(NOW(), hire_date) > 365;
```

> 📸 **截图5:** 常用函数执行结果

---

## 七、综合实战案例

```sql
-- 案例1:查技术部薪资>8000且入职超1年的员工
SELECT name, salary, hire_date
FROM employee
WHERE department = '技术部' AND salary > 8000
  AND DATEDIFF(NOW(), hire_date) > 365
ORDER BY salary DESC;

-- 案例2:统计平均工资>7500的部门
SELECT department, COUNT(*) AS 人数, AVG(salary) AS 平均工资
FROM employee
GROUP BY department
HAVING AVG(salary) > 7500
ORDER BY 平均工资 DESC;

-- 案例3:查每个部门工资最高的员工(子查询)
SELECT e.name, e.department, e.salary
FROM employee e
WHERE e.salary = (
    SELECT MAX(salary) FROM employee WHERE department = e.department
);
```

> 📸 **截图6:** 综合案例执行结果

---

## 八、性能优化要点

1. **避免SELECT *:** 需要啥字段查啥,减少网络传输
2. **用LIMIT限制:** 大数据集加LIMIT,避免一次查太多
3. **WHERE中别用函数:** `WHERE YEAR(hire_date) = 2023`会索引失效,改成`WHERE hire_date >= '2023-01-01' AND hire_date < '2024-01-01'`

具体优化原理第5讲《索引》详细讲解。

---

## 九、今天学了啥?快速回顾

### 核心SQL语句

```sql
-- INSERT:批量插入效率高10倍
INSERT INTO employee (name, salary) VALUES ('张三', 8000), ('李四', 9000);

-- SELECT:条件+排序+分页+聚合
SELECT department, COUNT(*), AVG(salary)
FROM employee
WHERE salary > 8000
GROUP BY department
HAVING AVG(salary) > 8000
ORDER BY AVG(salary) DESC
LIMIT 10;

-- JOIN:多表关联
SELECT e.name, d.location
FROM employee e INNER JOIN department d ON e.department = d.dept_name;

-- UPDATE/DELETE:必加WHERE+LIMIT
UPDATE employee SET salary = 9000 WHERE name = '张三' LIMIT 1;
DELETE FROM employee WHERE id = 5 LIMIT 1;
```

### 避坑要点

1. UPDATE/DELETE必加WHERE,否则改/删全表
2. 先SELECT确认,再执行UPDATE/DELETE
3. SELECT避免用`*`,WHERE避免用函数
4. 批量插入比单条快10倍,分页OFFSET别太大

---

## 十、作业:10个查询练习

基于employee和department表,完成以下查询:

**基础(1-4):**
1. 查询所有员工的姓名和薪资
2. 查询技术部的所有员工
3. 查询薪资在7000-9000之间的员工
4. 查询薪资>8000的员工,按薪资降序

**条件(5-6):**
5. 查询姓"张"或"李"的员工(用LIKE或IN)
6. 查询2023年入职的员工(用BETWEEN或范围)

**聚合(7-8):**
7. 统计各部门人数和平均薪资
8. 查询薪资最高的前3名员工

**进阶(9-10):**
9. 查询各部门工资最高的员工(子查询)
10. 查询员工和所在部门城市(INNER JOIN)

把你的SQL写出来,对照答案检查!

---

## 十二、下一讲预告

今天咱们把增删改查的基础操作都搞定了。但SQL还有更强大的功能等着你！

**第4讲:现代SQL高级特性——窗口函数与CTE**

MySQL 8.0+引入了窗口函数和CTE,这是面试高频考点,也是解决复杂查询的利器:

- **窗口函数:**每部门薪资排名TOP3?每月销售额环比增长?不用复杂子查询,一个ROW_NUMBER搞定!
- **CTE公共表表达式:**复杂SQL嵌套5层看不懂?用WITH子句拆分,代码清晰10倍!
- **递归CTE:**查询员工的所有上级?商品分类树?递归查询轻松搞定!

这些特性在面试中经常被问到,在实际工作中也能显著提升SQL的可读性和性能。

**准备工作:**
- 完成今天的10个查询作业
- 确保已掌握JOIN和GROUP BY
- 思考:如何用一条SQL查询每个部门薪资前3名?(不用窗口函数会很复杂)

---

**下一讲见!咱们一起学习现代SQL的强大特性!**

