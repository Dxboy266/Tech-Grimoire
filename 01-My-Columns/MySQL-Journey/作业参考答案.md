# MySQL Journey 作业参考答案

> 本文档包含第1-7讲的作业参考答案，供学习参考。


## 第1讲：把MySQL当成Excel来学

### 作业：分析Excel文件并设计MySQL结构

**示例：学生成绩管理.xlsx**

**原Excel结构：**
- Sheet1"学生信息"：学号、姓名、性别、班级
- Sheet2"考试成绩"：学号、科目、分数、考试日期

**转换为MySQL：**

```sql
-- 数据库
CREATE DATABASE school_db;
USE school_db;

-- 学生表
CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT '学号',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    gender ENUM('男', '女') NOT NULL COMMENT '性别',
    class VARCHAR(30) NOT NULL COMMENT '班级'
) COMMENT '学生表';

-- 成绩表
CREATE TABLE score (
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT '编号',
    student_id INT NOT NULL COMMENT '学号',
    subject VARCHAR(30) NOT NULL COMMENT '科目',
    score DECIMAL(5,2) NOT NULL COMMENT '分数',
    exam_date DATE NOT NULL COMMENT '考试日期',
    INDEX idx_student_id(student_id)
) COMMENT '成绩表';
```

**痛点分析：**
1. 多人同时录成绩会冲突 → MySQL并发控制+事务解决
2. 学生多了Excel很慢 → MySQL索引加速
3. 容易误删数据 → MySQL权限管理+备份恢复


## 第2讲：环境搭建与数据类型设计

### 作业：创建学生管理系统

```sql
-- 1. 创建数据库
CREATE DATABASE IF NOT EXISTS school_db;
USE school_db;

-- 2. 创建学生表
CREATE TABLE student (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '学号',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    gender ENUM('男', '女') NOT NULL COMMENT '性别',
    birthday DATE NOT NULL COMMENT '出生日期',
    class VARCHAR(30) NOT NULL COMMENT '班级',
    phone VARCHAR(11) COMMENT '手机号'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生表';

-- 3. 创建成绩表
CREATE TABLE score (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '编号',
    student_id INT NOT NULL COMMENT '学号',
    subject VARCHAR(30) NOT NULL COMMENT '科目',
    score DECIMAL(5,2) NOT NULL COMMENT '分数',
    exam_date DATE NOT NULL COMMENT '考试日期'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='成绩表';

-- 4. 插入学生数据
INSERT INTO student (name, gender, birthday, class) VALUES
('张三', '男', '2005-03-15', '高一1班'),
('李四', '女', '2005-07-22', '高一1班'),
('王五', '男', '2005-01-08', '高一2班');

-- 5. 插入成绩数据
INSERT INTO score (student_id, subject, score, exam_date) VALUES
(1, '数学', 85.5, '2024-01-15'),
(1, '语文', 92.0, '2024-01-15'),
(2, '数学', 78.0, '2024-01-15'),
(2, '语文', 88.5, '2024-01-15'),
(3, '数学', 95.0, '2024-01-15');

-- 6. 查询所有学生信息
SELECT * FROM student;
```

## 第3讲：增删改查实战

### 基础查询(1-3)

```sql
-- 1. 查询所有员工的姓名和薪资
SELECT name, salary FROM employee;

-- 2. 查询技术部的所有员工
SELECT * FROM employee WHERE department = '技术部';

-- 3. 查询薪资在7000-9000之间的员工
SELECT * FROM employee WHERE salary BETWEEN 7000 AND 9000;
```

### 条件查询(4-6)

```sql
-- 4. 查询薪资>8000的员工，按薪资降序排列
SELECT * FROM employee WHERE salary > 8000 ORDER BY salary DESC;

-- 5. 查询姓"张"或"李"的员工
SELECT * FROM employee WHERE name LIKE '张%' OR name LIKE '李%';

-- 6. 查询入职日期在2023年的员工
SELECT * FROM employee 
WHERE hire_date >= '2023-01-01' AND hire_date < '2024-01-01';
```

### 聚合统计(7-8)

```sql
-- 7. 统计各部门的人数和平均薪资
SELECT department, COUNT(*) AS 人数, AVG(salary) AS 平均薪资
FROM employee
GROUP BY department;

-- 8. 查询薪资最高的前3名员工
SELECT * FROM employee ORDER BY salary DESC LIMIT 3;
```

### 复杂查询(9-10)

```sql
-- 9. 查询各部门薪资最高的员工（用子查询）
SELECT e.name, e.department, e.salary
FROM employee e
WHERE e.salary = (
    SELECT MAX(salary) FROM employee WHERE department = e.department
);

-- 10. 查询员工和所在部门的城市（用JOIN）
SELECT e.name, e.salary, d.location
FROM employee e
INNER JOIN department d ON e.department = d.dept_name;
```


## 第4讲：窗口函数与CTE

### 基础练习

```sql
-- 1. 查询每个部门薪资排名前3的员工
SELECT * FROM (
    SELECT 
        department, name, salary,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn
    FROM employee
) t WHERE rn <= 3;

-- 2. 计算每个员工的薪资与部门平均薪资的差距
SELECT 
    name, department, salary,
    AVG(salary) OVER (PARTITION BY department) AS dept_avg,
    salary - AVG(salary) OVER (PARTITION BY department) AS diff_from_avg
FROM employee;

-- 3. 查询每个员工的上一名和下一名
SELECT 
    name, salary,
    LAG(name, 1) OVER (ORDER BY salary DESC) AS higher_person,
    LEAD(name, 1) OVER (ORDER BY salary DESC) AS lower_person
FROM employee;

-- 4. 查询每个部门薪资最高和最低的员工
SELECT 
    name, department, salary,
    FIRST_VALUE(name) OVER (PARTITION BY department ORDER BY salary DESC) AS highest_person,
    FIRST_VALUE(name) OVER (PARTITION BY department ORDER BY salary ASC) AS lowest_person
FROM employee;
```

### 进阶挑战

```sql
-- 5. 用递归CTE查询某员工的所有下属
-- 假设有manager_id字段
WITH RECURSIVE subordinates AS (
    SELECT id, name, manager_id, 1 AS level
    FROM employee WHERE id = 1  -- 从某个员工开始
    UNION ALL
    SELECT e.id, e.name, e.manager_id, s.level + 1
    FROM employee e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates;

-- 6. 用窗口函数实现分页（替代LIMIT OFFSET）
-- 查询第3页，每页10条
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS rn
    FROM employee
) t WHERE rn BETWEEN 21 AND 30;
```


## 第5讲：事务

### 作业1：复现脏读

```sql
-- 终端1：设置隔离级别并开启事务
SET SESSION TRANSACTION_ISOLATION = 'READ-UNCOMMITTED';
START TRANSACTION;
UPDATE account SET balance = 500 WHERE user_id = 1;
-- 不要提交，保持事务打开

-- 终端2：设置隔离级别并查询
SET SESSION TRANSACTION_ISOLATION = 'READ-UNCOMMITTED';
SELECT * FROM account WHERE user_id = 1;
-- 可以看到balance=500（脏读）

-- 终端1：回滚
ROLLBACK;

-- 终端2：再次查询
SELECT * FROM account WHERE user_id = 1;
-- balance恢复原值，之前读到的是"脏数据"
```

### 作业2：思考题

**为什么MySQL默认RR，Oracle默认RC？**

历史原因：MySQL早期主从复制使用Statement格式的binlog，在RC级别下可能导致主从数据不一致。RR级别配合间隙锁可以避免这个问题。

Oracle没有这个历史包袱，RC级别性能更好，所以选择RC作为默认。


## 第6讲：索引（上）

### 基础题

**第1题：手绘B+树结构**

```
                    [10, 20, 30]  ← 根节点
                   /     |     \
            [4,7]    [15,17]   [25,28]  ← 内部节点
           /  |  \    /  |  \   /  |  \
         [1,2,3][7,8,9]...           ← 叶子节点（双向链表连接）
         
查找值25的路径：
1. 根节点：25 > 20，走右分支
2. 内部节点[25,28]：25 = 25，找到
3. 进入对应叶子节点获取完整数据
```

**第2题：计算B+树存储容量**

```
已知：
- 索引字段BIGINT(8字节) + 页指针(6字节) = 14字节
- 一行数据500字节
- 页大小16KB = 16384字节

计算：
1. 非叶子节点能存索引数：16384 / 14 ≈ 1170个
2. 叶子节点能存数据行数：16384 / 500 ≈ 32行
3. 3层B+树存储量：
   - 第1层：1个页，1170个索引
   - 第2层：1170个页，1170×1170 = 1,368,900个索引
   - 第3层：1,368,900个页，每页32行 = 43,804,800行

结论：3层B+树可存储约4380万行数据
```

### 进阶题

**第1题：分析最左匹配原则**

```sql
-- 索引：idx_user_status_time(user_id, status, created_at)

-- A: WHERE user_id = 10001;
-- ✅ 能用索引，使用最左字段user_id

-- B: WHERE user_id = 10001 AND status = 0;
-- ✅ 能用索引，使用前两个字段

-- C: WHERE user_id = 10001 AND created_at > '2024-01-01';
-- ⚠️ 部分使用，只用到user_id，created_at用不上（中间断层）

-- D: WHERE status = 0 AND created_at > '2024-01-01';
-- ❌ 不能用索引，跳过了最左字段user_id

-- E: WHERE user_id = 10001 AND status = 0 AND created_at > '2024-01-01';
-- ✅ 能用索引，使用全部字段
```

**第2题：设计联合索引**

```sql
-- 查询：WHERE user_id = 10001 AND status = 0 ORDER BY created_at DESC

-- 索引设计：
CREATE INDEX idx_user_status_time ON orders(user_id, status, created_at);

-- 原因：
-- 1. user_id区分度高，放最前面
-- 2. status是等值查询，放第二位
-- 3. created_at用于排序，放最后
-- 4. 这样可以避免filesort，直接利用索引排序
```


## 第7讲：索引（下）

### 基础题

**第1题：分析索引失效原因并优化**

```sql
-- A. 查询2025年的订单
-- 失效原因：YEAR()函数导致索引失效
SELECT * FROM orders WHERE YEAR(created_at) = 2025;
-- 优化：改用范围查询
SELECT * FROM orders 
WHERE created_at >= '2025-01-01' AND created_at < '2026-01-01';

-- B. 查询手机号
-- 失效原因：隐式类型转换（phone是VARCHAR，传入数字）
SELECT * FROM user WHERE phone = 13800138000;
-- 优化：加引号
SELECT * FROM user WHERE phone = '13800138000';

-- C. 模糊查询
-- 失效原因：左模糊（%在前面）
SELECT * FROM user WHERE name LIKE '%张%';
-- 优化：如果业务允许，改用前缀匹配
SELECT * FROM user WHERE name LIKE '张%';
-- 或使用ElasticSearch

-- D. 不等于查询
-- 失效原因：不等于通常匹配大部分数据，优化器放弃索引
SELECT * FROM orders WHERE status != 0;
-- 优化：如果status值有限，改用IN
SELECT * FROM orders WHERE status IN (1, 2);
```

### 进阶题

**第1题：慢查询优化实战**

```sql
-- 原SQL
SELECT * FROM orders
WHERE user_id = 10001 AND status IN (0, 1)
ORDER BY amount DESC
LIMIT 10;

-- EXPLAIN分析问题：
-- 可能出现Using filesort（额外排序）

-- 索引方案：
CREATE INDEX idx_user_status_amount ON orders(user_id, status, amount);

-- 注意：由于status是IN查询，amount排序可能无法完全利用索引
-- 如果性能仍不理想，可以考虑：
-- 方案1：拆分查询
SELECT * FROM orders WHERE user_id = 10001 AND status = 0 ORDER BY amount DESC LIMIT 10
UNION ALL
SELECT * FROM orders WHERE user_id = 10001 AND status = 1 ORDER BY amount DESC LIMIT 10
ORDER BY amount DESC LIMIT 10;

-- 方案2：如果数据量不大，接受filesort
```

**第2题：索引设计方案**

```sql
-- 商品表高频查询场景

-- 索引1：按类目+品牌+状态查询，按价格排序
CREATE INDEX idx_cat_brand_status_price ON products(category_id, brand_id, status, price);
-- 支持查询1

-- 索引2：按类目+状态查询，按创建时间排序
CREATE INDEX idx_cat_status_time ON products(category_id, status, created_at);
-- 支持查询2

-- 索引3：按品牌查询库存不足
CREATE INDEX idx_brand_stock ON products(brand_id, stock);
-- 支持查询3

-- 分析：
-- 查询1：使用idx_cat_brand_status_price，等值查询在前，排序字段在后
-- 查询2：使用idx_cat_status_time，等值查询在前，排序字段在后
-- 查询3：使用idx_brand_stock，brand_id等值，stock范围查询
```
