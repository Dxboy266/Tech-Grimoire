# 第2讲:环境搭建与数据类型设计

> **目标:** 快速搭建MySQL环境,掌握数据类型选择,避免生产事故

---

## 开篇:安装不是重点,但得装对了

上一讲咱们把MySQL和Excel的关系搞清楚了。今天要动手了——装MySQL、建表、插数据。

安装MySQL本身不难,但有几个坑得提前告诉你:**字符集选错了emoji存不进去、金额字段用错类型会丢精度、外键约束用不用要看场景**。这些都是生产环境的血泪教训。

今天我会用最快的方式带你搭好环境,然后把数据类型的坑给你讲清楚,保证你以后不踩。

---

## 一、5分钟搞定MySQL环境

### 推荐方案:Docker(一行命令搞定)

**为什么推荐Docker?**
- 一行命令就装好,不用点来点去
- 环境隔离,不会把你电脑搞乱
- 想换版本?删了重装,30秒搞定

**Docker是啥?怎么装?**

Docker就是个"轻量级虚拟机",能把MySQL装在一个独立的"容器"里,和你的电脑系统完全隔离。

**Windows/Mac装Docker:**
1. 下载Docker Desktop: https://www.docker.com/products/docker-desktop
2. 双击安装,一路下一步(可能需要重启)
3. 装完后桌面有个Docker图标,打开它(鲸鱼图标)
4. 底部显示"Docker is running"就成了

> 📸 **截图1:** Docker Desktop安装成功界面

**Linux装Docker:**
```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# CentOS/RHEL
sudo yum install -y docker-ce
sudo systemctl start docker
```

**Docker装好后,启动MySQL只需要这一条命令:**

```bash
docker run -d \
  --name mysql8 \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=your_password \
  -e MYSQL_DATABASE=testdb \
  -e TZ=Asia/Shanghai \
  mysql:8.0 \
  --character-set-server=utf8mb4 \
  --collation-server=utf8mb4_unicode_ci
```

**命令解释:**
- `--name mysql8`: 给容器起个名字
- `-p 3306:3306`: 把容器的3306端口映射到本机(MySQL默认端口)
- `-e MYSQL_ROOT_PASSWORD`: 设置root密码
- `mysql:8.0`: 用MySQL 8.0版本
- `--character-set-server=utf8mb4`: **重点!字符集用utf8mb4,支持emoji**

**登录MySQL:**
```bash
docker exec -it mysql8 mysql -uroot -p
# 输入你设置的密码
```

看到`mysql>`提示符就成功了!

> 📸 **截图2:** Docker启动MySQL并登录成功

---

### 备用方案:Windows/Linux本地安装

Docker装不上?没关系,用传统方式也行,就是步骤多点。

**Windows极简步骤:**

1. 下载MySQL 8.0 ZIP包(不是MSI安装包)
   - 官网: https://dev.mysql.com/downloads/mysql/
   - 选择`Windows (x86, 64-bit), ZIP Archive`

2. 解压到`D:\mysql-8.0`(路径别带中文和空格)

3. 在`D:\mysql-8.0`目录下创建文件`my.ini`:
```ini
[mysqld]
basedir=D:\mysql-8.0
datadir=D:\mysql-8.0\data
port=3306
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci
```

4. 管理员权限打开CMD,执行:
```cmd
cd D:\mysql-8.0\bin

# 初始化(会生成临时密码,记下来)
mysqld --initialize --console

# 安装为Windows服务
mysqld --install

# 启动服务
net start MySQL
```

5. 登录并改密码:
```cmd
mysql -u root -p
# 输入刚才的临时密码

# 改密码
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_new_password';
```

> 📸 **截图3:** Windows初始化成功,临时密码显示(红框标注)

**Linux(Ubuntu)极简步骤:**

```bash
sudo apt update
sudo apt install mysql-server
sudo systemctl start mysql
sudo mysql_secure_installation  # 设置密码
```

**常见问题速查表:**

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| 端口3306被占用 | 已有MySQL或其他程序占用 | `netstat -ano | findstr 3306` 查占用进程 |
| 忘记密码 | - | 停服务→`mysqld --skip-grant-tables`跳过验证→重置密码 |
| 连不上Docker里的MySQL | 端口没映射或防火墙拦截 | 检查`-p 3306:3306`是否加了,关闭防火墙试试 |

---

## 二、选个趁手的工具

MySQL装好了,接下来选个客户端工具。有两个选择:命令行或图形化工具。

### 命令行:高效但不直观

登录:`mysql -u root -p`  
退出:`exit`

**优点:** 轻量快速,适合写脚本,服务器上必用  
**缺点:** 不直观,刚开始容易打错

### Navicat/DBeaver:新手友好

**Navicat:** 
- 收费,有14天试用
- 界面漂亮,功能强大
- 下载: https://www.navicat.com.cn/

**DBeaver:**
- 完全免费开源
- 支持多种数据库
- 下载: https://dbeaver.io/

**连接配置:**
- 主机:`localhost`(或`127.0.0.1`)
- 端口:`3306`
- 用户名:`root`
- 密码:你设置的密码

> 📸 **截图4:** Navicat连接配置界面 + 连接成功

**我的建议:** 新手先用Navicat或DBeaver,熟练了再用命令行。两个都会,走到哪都不怕。

---

## 三、数据类型选择:这是避坑的关键

建表时,每个字段要选数据类型。选对了,省空间、查询快;选错了,轻则浪费空间,重则丢数据、出bug。

### 整数类型:别动不动就BIGINT

| 类型 | 字节 | 范围 | 什么时候用 | 反面教材 |
|------|------|------|-----------|---------|
| TINYINT | 1字节 | -128~127 | 状态(0/1)、年龄 | 用INT存状态 |
| INT | 4字节 | -21亿~21亿 | **用户ID、订单ID** | 所有ID都用BIGINT |
| BIGINT | 8字节 | ±9×10^18 | 超大数据量、雪花ID | 小表也用BIGINT |

**举个例子:**

```sql
-- ✅ 正确:按需选择
CREATE TABLE users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 42亿够用
    age TINYINT UNSIGNED,                         -- 年龄0-255够用
    status TINYINT DEFAULT 1                      -- 状态:1正常 0禁用
);

-- ❌ 错误:过度使用BIGINT
CREATE TABLE users (
    id BIGINT,      -- 浪费4字节,100万用户就浪费4MB
    age BIGINT,     -- 浪费7字节
    status BIGINT   -- 浪费7字节
);
```

**避坑提示:** 手机号别用BIGINT!用VARCHAR(11)!因为手机号有前导0,比如`01012345678`,存成数字前导0就没了。

---

### 小数类型:金额字段千万别用FLOAT

**这是生产事故高发区!**

| 类型 | 精度 | 什么时候用 | 反面教材 |
|------|------|-----------|---------|
| **DECIMAL(M,D)** | 精确 | **金额、价格(必须用)** | ❌用FLOAT存金额 |
| FLOAT | 近似(7位) | 科学计算 | 用于金额丢精度 |
| DOUBLE | 近似(15位) | 科学计算 | 用于金额丢精度 |

**实战验证:FLOAT为啥不能存金额?**

```sql
-- 创建测试表
CREATE TABLE test_money (
    amount_decimal DECIMAL(10,2),
    amount_float FLOAT
);

-- 插入0.01、0.02、0.03
INSERT INTO test_money VALUES (0.01, 0.01);
INSERT INTO test_money VALUES (0.02, 0.02);
INSERT INTO test_money VALUES (0.03, 0.03);

-- 求和看看
SELECT 
    SUM(amount_decimal) AS decimal_sum,  -- 结果:0.06
    SUM(amount_float) AS float_sum        -- 结果:0.059999998
FROM test_money;
```

看到了吗?0.01+0.02+0.03本该等于0.06,FLOAT算出来是0.059999998!

如果这是支付系统,10万笔订单累计下来,误差几千块都有可能!

**正确做法:**

```sql
-- ✅ 金额必须用DECIMAL
CREATE TABLE orders (
    total_amount DECIMAL(10,2),  -- 10位数字,2位小数,最大99999999.99
    discount_amount DECIMAL(10,2)
);
```

> 📸 **截图5:** DECIMAL vs FLOAT精度对比结果(0.06 vs 0.059999998)

---

### 字符串类型:固定长度用CHAR,变长用VARCHAR

| 类型 | 存储方式 | 什么时候用 | 反面教材 |
|------|---------|-----------|---------|
| **CHAR(N)** | 固定长度 | 身份证号、手机号 | 变长字段用CHAR |
| **VARCHAR(N)** | 变长 | 姓名、地址、标题 | N设置过大(如1000) |
| TEXT | 变长 | 文章内容、评论 | 给TEXT建索引 |

**CHAR vs VARCHAR的区别:**

- `CHAR(10)`存"abc",会补7个空格,占10字符
- `VARCHAR(10)`存"abc",只占3字符

长度固定用CHAR(省空间),不固定用VARCHAR。

**举个例子:**

```sql
-- ✅ 正确
CREATE TABLE users (
    mobile CHAR(11),         -- 手机号固定11位
    id_card CHAR(18),        -- 身份证固定18位
    name VARCHAR(50),        -- 姓名不固定,最长50
    address VARCHAR(200),    -- 地址不固定
    intro TEXT               -- 个人简介用TEXT
);

-- ❌ 错误
CREATE TABLE users (
    mobile VARCHAR(11),      -- 应该用CHAR
    name VARCHAR(1000),      -- 太大了,浪费空间
    intro VARCHAR(5000)      -- 应该用TEXT
);
```

---

### 时间类型:推荐用DATETIME,别用TIMESTAMP

| 类型 | 范围 | 时区 | 什么时候用 | 坑点 |
|------|------|------|-----------|------|
| **DATETIME** | 1000-9999年 | 不受时区影响 | **创建时间、更新时间(推荐)** | - |
| TIMESTAMP | 1970-2038年 | 自动转时区 | 自动更新时间 | ⚠️时区问题 |
| DATE | 1000-9999年 | - | 生日、入职日期 | - |

**TIMESTAMP的坑:时区改了数据就变了**

假设你在北京(东8区)插入数据`2024-01-01 10:00:00`,存进去是这个时间。后来服务器迁到美国(西5区),时区改了,再查这条数据,变成`2024-01-01 02:00:00`了!

数据没动,但时间自动转换了,这很危险。

**正确做法:**

```sql
-- ✅ 推荐:用DATETIME
CREATE TABLE orders (
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- ❌ 不推荐:TIMESTAMP有时区问题
CREATE TABLE orders (
    created_at TIMESTAMP
);
```

---

## 四、字符集:必须用utf8mb4,不然emoji存不进去

**MySQL有个大坑:utf8不是真正的UTF-8!**

MySQL的`utf8`实际上是`utf8mb3`,最多3个字节,**不支持emoji和生僻字**。

真正的UTF-8是`utf8mb4`,4个字节,啥都能存。

| 字符集 | 字节数 | emoji支持 | 推荐 |
|-------|--------|----------|------|
| utf8 | 最多3字节 | ❌不支持 | ❌别用 |
| **utf8mb4** | 最多4字节 | ✅支持 | ✅必须用 |

**实战验证:**

```sql
-- 创建utf8的表
CREATE TABLE test_utf8 (
    nickname VARCHAR(50)
) CHARACTER SET utf8;

-- 插入emoji
INSERT INTO test_utf8 (nickname) VALUES ('张三😊');
-- 报错!Incorrect string value: '\xF0\x9F\x98\x8A...'

-- 创建utf8mb4的表
CREATE TABLE test_utf8mb4 (
    nickname VARCHAR(50)
) CHARACTER SET utf8mb4;

-- 插入emoji
INSERT INTO test_utf8mb4 (nickname) VALUES ('张三😊');
-- 成功!查询也正常显示
```

**正确做法:**

```sql
-- ✅ 建库时指定utf8mb4
CREATE DATABASE mydb 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- ✅ 建表时也指定
CREATE TABLE users (
    nickname VARCHAR(50)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

> 📸 **截图6:** utf8mb4成功存储emoji的效果

**排序规则选哪个?**

- `utf8mb4_unicode_ci`: 不区分大小写,通用场景**(推荐)**
- `utf8mb4_bin`: 区分大小写,适合密码字段

---

## 五、约束机制:保证数据质量

约束就是给字段加规则,防止脏数据进来。

### 主键约束(PRIMARY KEY)

**作用:** 唯一标识一行记录,不能重复,不能为空。

```sql
-- 单列主键
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);

-- 复合主键(多列组合唯一)
CREATE TABLE student_course (
    student_id INT,
    course_id INT,
    score INT,
    PRIMARY KEY (student_id, course_id)
);
```

---

### 非空约束(NOT NULL)

**作用:** 这个字段必须填,不能空着。

```sql
CREATE TABLE users (
    name VARCHAR(50) NOT NULL,      -- 姓名必填
    email VARCHAR(100) NOT NULL     -- 邮箱必填
);
```

---

### 唯一约束(UNIQUE)

**作用:** 这个字段的值不能重复。

```sql
CREATE TABLE users (
    email VARCHAR(100) UNIQUE,      -- 邮箱不能重复
    mobile CHAR(11) UNIQUE          -- 手机号不能重复
);
```

---

### 检查约束(CHECK)

**作用:** 限制字段的取值范围(MySQL 8.0.16+才支持)。

```sql
CREATE TABLE employees (
    age INT CHECK (age >= 18 AND age <= 65),      -- 年龄18-65
    salary DECIMAL(10,2) CHECK (salary > 0)       -- 薪资必须大于0
);
```

---

### 外键约束(FOREIGN KEY):用还是不用?

**作用:** 保证数据完整性,子表的外键值必须在父表存在。

```sql
-- 父表:部门表
CREATE TABLE departments (
    id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

-- 子表:员工表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(id)
        ON DELETE CASCADE      -- 删除部门时,员工也删除
        ON UPDATE CASCADE      -- 更新部门ID时,员工也更新
);
```

**但是!生产环境要不要用外键?这是个有争议的话题。**

| 维度 | 优点 | 缺点 |
|------|------|------|
| 数据完整性 | ✅数据库层面保证一致性 | - |
| 性能 | - | ❌影响INSERT/UPDATE性能 |
| 灵活性 | - | ❌分库分表后无法使用 |
| 调试 | - | ❌删除数据时可能被外键阻止 |

**生产实践:**
- **互联网公司90%不用外键**,靠应用代码保证数据一致性
- **传统企业/银行可能使用**,数据一致性要求极高
- **面试必须会**,外键的创建、级联操作要懂

---

## 六、实战:创建员工管理表

把今天学的知识综合起来,创建一个规范的员工表。

### 需求分析

- 员工ID:自增主键
- 姓名:必填
- 邮箱:唯一
- 年龄:18-65
- 薪资:DECIMAL,必须>0
- 部门ID:外键(可选)
- 创建时间、更新时间

### 完整建表语句

```sql
-- 部门表
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    dept_name VARCHAR(50) NOT NULL UNIQUE COMMENT '部门名称',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='部门表';

-- 员工表
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '员工ID',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    email VARCHAR(100) UNIQUE COMMENT '邮箱',
    mobile CHAR(11) UNIQUE COMMENT '手机号',
    age INT CHECK (age >= 18 AND age <= 65) COMMENT '年龄',
    salary DECIMAL(10,2) CHECK (salary > 0) COMMENT '薪资',
    dept_id INT NOT NULL COMMENT '部门ID',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE RESTRICT,
    INDEX idx_dept_id (dept_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='员工表';
```

**插入测试数据:**

```sql
-- 插入部门
INSERT INTO departments (dept_name) VALUES ('技术部'), ('市场部'), ('人力部');

-- 插入员工
INSERT INTO employees (name, email, mobile, age, salary, dept_id) VALUES
('张三', 'zhangsan@qq.com', '13800138000', 25, 8000.00, 1),
('李四', 'lisi@qq.com', '13800138001', 28, 9000.00, 1),
('王五', 'wangwu@qq.com', '13800138002', 30, 7000.00, 2);

-- 查询
SELECT * FROM employees;
```

> 📸 **截图7:** 员工表创建成功并插入测试数据

---

## 七、避坑指南:今天必须记住的4个坑

### 坑1:金额用FLOAT导致精度丢失

```sql
-- ❌ 错误:0.01+0.02可能=0.029999999
total_amount FLOAT

-- ✅ 正确
total_amount DECIMAL(10,2)
```

---

### 坑2:字符集用utf8无法存储emoji

```sql
-- ❌ 错误:微信昵称带emoji存不进去
CHARACTER SET utf8

-- ✅ 正确
CHARACTER SET utf8mb4
```

---

### 坑3:TIMESTAMP时区问题

```sql
-- ❌ 错误:服务器时区改变,数据自动转换
created_at TIMESTAMP

-- ✅ 正确
created_at DATETIME
```

---

### 坑4:VARCHAR长度设置过大

```sql
-- ❌ 错误:浪费空间,索引性能差
name VARCHAR(1000)

-- ✅ 正确:根据实际需求设置
name VARCHAR(50)
```

---

## 八、今天学了啥?快速回顾

### MySQL安装(Docker推荐)

```bash
# 一行命令启动MySQL
docker run -d --name mysql8 -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=your_password mysql:8.0 \
  --character-set-server=utf8mb4
```

### 数据类型选择速记

- **整数:** 用INT,别动不动BIGINT
- **金额:** 必须DECIMAL,禁止FLOAT
- **字符串:** 固定长度CHAR,变长VARCHAR
- **时间:** 推荐DATETIME,避免TIMESTAMP
- **字符集:** 必须utf8mb4,别用utf8

### 建表标准模板

```sql
CREATE TABLE table_name (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    amount DECIMAL(10,2) CHECK (amount > 0),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

---

## 九、作业:动手练一练

### 基础练习

1. 用Docker安装MySQL 8.0并成功连接
2. 验证DECIMAL和FLOAT的精度差异(插入0.01+0.02+0.03并求和)
3. 验证utf8和utf8mb4对emoji的支持(尝试插入带emoji的昵称)

### 进阶挑战

4. 创建一个电商商品表,要求:
   - 商品ID(主键、自增)
   - 商品名称(必填、最长100字符)
   - 价格(DECIMAL、必须>0)
   - 库存(非负整数)
   - 状态(1上架 0下架)
   - 分类ID(外键关联分类表)
   - 创建时间、更新时间

5. 设计一个完整的学生管理系统表结构(学生表、课程表、选课表、成绩表),包含所有必要约束

---

## 十、下一讲预告

环境搭好了,表也会建了,数据类型的坑也知道了。下一讲要学的是你以后天天要用的:**增删改查**。

**第3讲:增删改查实战——搞定80%日常需求**

- INSERT的多种写法(批量插入效率高10倍)
- SELECT进阶:WHERE条件、多表JOIN、聚合统计
- UPDATE和DELETE的血泪教训(为啥必须加WHERE)
- 常用函数:字符串处理、日期计算

这四个操作占了你日常工作的80%,搞定了这些,MySQL就算入门了。

**建议提前准备:**
- 完成今天的作业,创建好员工表
- 给employees表多插点测试数据(10-20条),方便下一讲练习各种查询

---

**下一讲见!**
