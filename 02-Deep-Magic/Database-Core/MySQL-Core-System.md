### **[文档生成] MySQL 核心知识体系深度汇总**

#### **一、 存储引擎与索引原理 (The Core)**
*决定了数据怎么存、查得有多快*

1.  **B+ 树 (B+ Tree)**
    *   **为什么是 B+ 树？** 为了减少磁盘 I/O。非叶子节点只存索引（路标），叶子节点存所有数据。层高通常 3 层，意味着千万级数据只需 3 次 I/O。
    *   **聚簇索引 (Clustered Index)**：主键索引。叶子节点 = 整行数据。表数据本身就是按主键排序的。
    *   **二级索引 (Secondary Index)**：非主键索引。叶子节点 = 索引列 + 主键 ID。查数据通常需要 **回表**（拿着 ID 回聚簇索引再查一次）。

2.  **索引优化黄金法则**
    *   **最左前缀原则**：联合索引 `(a, b, c)`，查询 `(a, b)` 有效，只查 `(b)` 或 `(c)` 无效（断层了）。
    *   **覆盖索引 (Covering Index)**：`SELECT a, b FROM t WHERE a=1`。数据直接从索引树拿，不需要回表。**性能极高**。
    *   **索引下推 (ICP)**：MySQL 5.6+ 优化。在索引遍历过程中，直接利用索引里的残余数据做过滤，减少回表次数。
    *   **失效场景**：对索引列做运算、类型隐式转换（String 变 Int）、`LIKE '%abc'`。

#### **二、 事务与锁 (Concurrency & Consistency)**
*决定了并发安不安全、会不会死锁*

1.  **事务隔离级别 (Isolation Levels)**
    *   **RC (读已提交)**：防脏读。每次 SELECT 生成新快照。并发高，无间隙锁。
    *   **RR (可重复读, 默认)**：防脏读、不可重复读。第一次 SELECT 生成快照，后面复用。靠 **Next-Key Lock** 防幻读（但会导致死锁风险增加）。

2.  **锁机制 (Locking)**
    *   **行锁 (Record Lock)**：锁住某一行。
    *   **间隙锁 (Gap Lock)**：锁住行之间的空隙（RR 级别特有），防止别人插入。**死锁之源**。
    *   **临键锁 (Next-Key Lock)**：行锁 + 间隙锁。
    *   **意向锁 (IS/IX)**：表级标记，为了提升加表锁的效率（不用遍历行）。
    *   **MDL 锁 (Metadata Lock)**：增删改查自动加读锁，改表结构加写锁。**注意长事务会卡死 DDL**。

3.  **死锁经典场景**
    *   **INSERT 并发**：唯一键冲突导致多个事务加 Gap Lock，互斥等待插入意向锁。
    *   **乱序更新**：事务 A 锁 (1, 2)，事务 B 锁 (2, 1)。**解法：统一应用层加锁顺序**。

#### **三、 性能分析与监控 (Diagnostics)**
*当你遇到慢 SQL 时该怎么办*

1.  **EXPLAIN 分析**
    *   **Type (重要性)**：`system > const > eq_ref > ref > range > index > ALL`。
        *   `ALL`：全表扫描，必须优化。
        *   `index`：全索引扫描，通常也很慢。
    *   **Extra (潜台词)**：
        *   `Using index`：好（覆盖索引）。
        *   `Using filesort`：坏（手工排序，缺排序索引）。
        *   `Using temporary`：坏（临时表，通常因 GROUP BY 导致）。

2.  **Performance Schema**
    *   上帝视角监控。分析锁等待、CPU 消耗、磁盘 I/O 的具体归属。

#### **四、 日志与持久化 (Logging & WAL)**
*决定了数据会不会丢、怎么恢复*

1.  **Redo Log (重做日志)** - *InnoDB 引擎层*
    *   **作用**：Crash-safe（断电恢复）。
    *   **机制**：**WAL (Write-Ahead Logging)**。先把随机写转为顺序写落盘，再由后台线程慢慢刷脏页。
    *   **特点**：循环写，物理逻辑日志。

2.  **Binlog (归档日志)** - *Server 层*
    *   **作用**：主从复制、数据恢复（回滚）。
    *   **机制**：追加写，逻辑日志。
    *   **两阶段提交 (2PC)**：确保 Redo Log 和 Binlog 的逻辑一致性，防止主从数据不一致。

#### **五、 架构与高可用 (Architecture)**
*决定了系统能扛多大流量*

1.  **主从复制**
    *   **流程**：Dump 线程推 -> IO 线程拉 -> Relay Log -> SQL 线程执行。
    *   **GTID**：全局事务 ID，解决主从切换时的位点对齐难题。
    *   **延迟解法**：强制读主、Redis 缓存标记法、半同步复制。

2.  **分库分表**
    *   **查询痛点**：非分片键查询（如按 ID 分片，查手机号）。
    *   **解法**：索引映射表、基因法（双写）、ES 异构索引（解决复杂搜索）。

#### **六、 内存与参数调优 (Tuning)**
*让 MySQL 跑得更快*

1.  **Buffer Pool (缓冲池)**
    *   **作用**：缓存数据页和索引页。
    *   **LRU 优化**：冷热分区（New/Old Sublist），防止全表扫描把热数据冲走。
    *   **配置**：`innodb_buffer_pool_size` 设为物理内存的 60-75%。

2.  **双 1 设置 (安全性)**
    *   `sync_binlog=1` + `innodb_flush_log_at_trx_commit=1`：最安全，适合核心金融业务。
    *   `(0, 2)` 或 `(1, 2)`：适合日志/监控业务，性能飞起，容忍丢失 1 秒数据。

3.  **连接数**
    *   `max_connections`：别太大（1000-2000），否则 CPU 上下文切换会拖死 DB。

---

**总结建议**：
这份文档是 MySQL 的**骨架**。面试或工作时，遇到问题先定位它是属于哪个模块（是锁问题？是索引问题？还是架构问题？），然后按图索骥。掌握到这个程度，你已经具备了高级后端工程师的数据库素养。