# DDD 领域驱动设计知识手册

> 本手册基于 Eric Evans《领域驱动设计》（蓝皮书）和 Vaughn Vernon《实现领域驱动设计》（红皮书）的核心思想编写，旨在提供一套严谨、系统的 DDD 知识体系。

## 一、DDD 的核心理念

领域驱动设计（Domain-Driven Design）不是一套框架，也不是一种特定的架构，而是一种**应对软件核心复杂性**的思维方式。

### 1.1 核心思想
- **软件的核心是其为用户解决领域问题的问题域**。
- 所有的技术实现（数据库、消息队列、框架）都应该服务于领域模型，而不是反过来。
- ** 通用语言（Ubiquitous Language） **是团队协作的基石，代码中的命名应直接反映业务概念。

### 1.2 学习路径建议
**正确的学习顺序：**
1.  **战略设计（Strategic Design）**：先看森林。理解问题域、限界上下文、上下文映射。这是架构师必须掌握的宏观视角。
2.  **战术设计（Tactical Design）**：再看树木。掌握实体、值对象、聚合、领域服务等构建块。这是开发人员落地的基础。
3.  **架构模式**：最后看如何组织代码（分层架构、六边形架构）。

**常见的误区：**
- ❌ **唯框架论**：认为用了 Cola、TMF 等框架就是 DDD。框架只是工具，DDD 是思想。
- ❌ **战术先行**：一上来就纠结实体和值对象，忽略了上下文边界的划分，导致"大泥球"。
- ❌ **数据库驱动**：先设计表结构，再生成实体，这是典型的"伪 DDD"。

---

## 二、战略设计（Strategic Design）

战略设计关注的是**问题空间（Problem Space）**和** 解决方案空间（Solution Space）**的宏观划分。

### 2.1 领域（Domain）与子域（Subdomain）
领域是我们要解决的现实问题。为了降低复杂度，我们需要将领域拆分为子域：

1.  **核心域（Core Domain）**：
    - 企业的核心竞争力，最值得投入精力的部分。
    - 比如电商系统的"交易"、"商品"。
2.  **支撑域（Supporting Domain）**：
    - 业务必须，但不是核心竞争力。
    - 比如电商系统的"字典数据"、"简单的促销配置"。
3.  **通用域（Generic Domain）**：
    - 行业通用的功能，可以购买现成方案或使用开源软件。
    - 比如"认证授权"、"邮件发送"。

### 2.2 限界上下文（Bounded Context）
**定义**：
限界上下文是语义的边界。同一个概念在不同的上下文中可能有完全不同的含义。

**示例**：
- 在**销售上下文**中，"商品"关注的是价格、描述、图片。
- 在**物流上下文**中，"商品"关注的是重量、体积、易碎性。

**原则**：
- **一个上下文 = 一种通用语言**。
- 理想情况下，一个限界上下文对应一个微服务。

### 2.3 上下文映射（Context Mapping）
限界上下文之间不是孤立的，它们需要协作。常见的映射关系包括：

1.  **合作关系（Partnership）**：双方紧密合作，共同失败或成功。
2.  **共享内核（Shared Kernel）**：共享一部分代码或模型（需谨慎使用）。
3.  **客户方-供应方（Customer-Supplier）**：上游（供应方）能够响应下游（客户方）的需求。
4.  **遵奉者（Conformist）**：下游只能盲目跟随上游的模型，上游不为下游做改变。
5.  **防腐层（Anticorruption Layer, ACL）**：下游通过适配层将上游模型转换为自己的模型，保护内部模型的纯净性。**这是最推荐的集成方式**。
6.  **开放主机服务（Open Host Service, OHS）**：上游定义一套公开协议（如 REST API），供所有下游使用。
7.  **发布语言（Published Language）**：通常与 OHS 配合，定义交互的数据格式（如 XML、JSON Schema）。

---

## 三、战术设计（Tactical Design）

战术设计关注的是**解决方案空间**中具体的构建块。

### 3.1 实体（Entity）
**定义**：由**唯一标识**（Identity）定义的对象，而非由其属性定义。
**特征**：
- 有生命周期（创建、修改、删除）。
- 属性可以变化，但标识不变。
- **示例**：用户（UserID）、订单（OrderID）。

### 3.2 值对象（Value Object）
**定义**：用于描述事物的特征，**没有唯一标识**的对象。
**特征**：
- **不可变（Immutable）**：一旦创建，不可修改。如果要改，必须替换整个对象。
- **相等性**：通过属性值判断相等，而非引用。
- **自验证**：构造时即保证数据的合法性。
- **示例**：颜色（RGB）、金额（数值+币种）、地址（省市区）。

> **专家建议**：尽可能多地使用值对象。它们更安全、更易于测试和维护。

### 3.3 聚合（Aggregate）与聚合根（Aggregate Root）
**定义**：
- **聚合**：一组相关对象的集合，作为一个整体被外界访问。它是**数据修改的最小单元**（事务边界）。
- **聚合根**：聚合中唯一允许被外部引用的实体。

**设计原则**：
1.  **在聚合边界内保证强一致性**。
2.  **设计小聚合**：不要试图把所有关联对象都拉进来。
3.  **通过唯一标识引用其他聚合**：不要持有其他聚合的引用，只持有 ID。
4.  **最终一致性**：聚合之间通过**领域事件**实现最终一致性。

### 3.4 领域服务（Domain Service）
**定义**：
当某个操作不属于任何一个实体或值对象时，将其封装为领域服务。
**特征**：
- 无状态。
- 包含核心业务逻辑。
- **示例**：转账（涉及两个账户实体的交互）、复杂的定价策略。

### 3.5 领域事件（Domain Event）
**定义**：领域中发生的、业务专家关心的事件。
**命名**：通常是过去式，如 `OrderCreated`、`PaymentConfirmed`。
**作用**：
- 解耦聚合。
- 触发副作用（发送邮件、更新报表）。
- 驱动跨上下文的最终一致性。

### 3.6 资源库（Repository）
**定义**：
资源库是聚合根的集合，提供类似集合的接口（add, remove, get）。
**与 DAO 的区别**：
- **DAO**：面向数据库表，处理 PO（Persistent Object）。
- **Repository**：面向领域模型，处理聚合根（Aggregate Root）。它负责将 DO 与 PO 进行转换。
- **原则**：**只有聚合根才配拥有资源库**。

---

## 四、架构模式

### 4.1 分层架构
标准的 DDD 分层架构如下：

1.  **用户接口层（User Interface）**：处理 HTTP 请求，解析参数。
2.  **应用层（Application Layer）**：
    - **很薄**，不包含业务逻辑。
    - 负责**编排**任务，协调领域对象和基础设施。
    - 对应 `Application Service`。
3.  **领域层（Domain Layer）**：
    - **核心层**，包含所有业务逻辑。
    - 包含实体、值对象、领域服务。
4.  **基础设施层（Infrastructure Layer）**：
    - 提供技术实现（数据库、缓存、MQ）。

### 4.2 依赖倒置（Dependency Inversion）
在传统架构中，上层依赖下层。但在 DDD 中，我们应用依赖倒置原则：
- **领域层不依赖任何其他层**。
- 基础设施层依赖领域层（通过实现领域层定义的接口）。
- 例如：`UserRepository` 接口定义在领域层，而 `UserRepositoryImpl` 实现定义在基础设施层。

### 4.3 防腐层（ACL）实践
当需要调用外部系统（如高德地图 API）时：
1.  **领域层**定义接口：`MapService`。
2.  **基础设施层**实现接口：`GaodeMapAdapter`。
3.  **适配器**负责将高德的请求/响应转换为领域模型需要的格式。
4.  业务逻辑只与 `MapService` 交互，完全不知道高德地图的存在。

---

## 五、工程实践与常见误区

### 5.1 贫血模型 vs 充血模型
- **贫血模型（Anemic Model）**：
    - 对象只有 Getter/Setter。
    - 业务逻辑全部堆积在 Service 层。
    - **后果**：对象只是数据载体，业务逻辑分散，难以维护。
- **充血模型（Rich Model）**：
    - 对象包含数据和行为。
    - 符合面向对象（OOP）的本意。
    - **原则**："数据在哪里，行为就在哪里"。

### 5.2 数据流转与对象转换
为了解耦，建议区分不同的数据对象：
1.  **DTO (Data Transfer Object)**：应用层与外界交互。
2.  **DO (Domain Object)**：领域层内部使用（实体、值对象）。
3.  **PO (Persistent Object)**：基础设施层与数据库交互。

**转换路径**：
`Controller (DTO)` -> `Application Service (DTO -> DO)` -> `Domain Layer` -> `Repository (DO -> PO)` -> `Database`

### 5.3 常见误区与专家洞察

**Q: 领域服务和应用服务怎么区分？**
> **专家洞察**：
> - 问自己：这段逻辑是业务规则（Domain）还是流程编排（Application）？
> - 如果去掉数据库、UI，这段逻辑依然成立，它就是领域逻辑 -> **领域服务**。
> - 如果这段逻辑涉及事务控制、日志记录、发送通知、调用第三方，它通常是 -> **应用服务**。

**Q: 所有的对象都要有 ID 吗？**
> **专家洞察**：
> 只有需要追踪生命周期的对象才需要 ID（实体）。如果两个对象属性完全一样就可以互换，那它就是值对象，不需要 ID。**过度使用实体是系统复杂的根源之一**。

**Q: 聚合应该多大？**
> **专家洞察**：
> 越小越好。大聚合会导致并发冲突和性能问题。通常一个聚合只包含一个实体（聚合根）和若干值对象。

**Q: 什么时候不该用 DDD？**
> **专家洞察**：
> - 简单的 CRUD 系统。
> - 业务逻辑非常简单，且未来没有演进计划。
> - 团队对 OOP 和建模缺乏基础理解（强行上 DDD 会变成灾难）。

---

## 六、参考资料

### 6.1 必读书籍
1.  **《领域驱动设计：软件核心复杂度的解决方法》** (Eric Evans) - 理论基石，必读。
2.  **《实现领域驱动设计》** (Vaughn Vernon) - 实践指南，必读。

### 6.2 延伸阅读
- 《架构整洁之道》(Robert C. Martin)
- 《微服务架构设计模式》(Chris Richardson)
