# 分布式锁设计的思考：从入门到“弃用” 

> **💡 核心摘要**
> 分布式锁不仅是一个技术组件，更是业务在“一致性”与“可用性”之间妥协的产物。
> 请记住：**最好的分布式锁设计，往往是“无锁”设计。**

---

## 一、 本质：从“自家厕所”到“公共厕所”

在单机多线程时代，`synchronized` 就像是你**家里的厕所门锁**，防君子不防小人，但至少能防住自家人（同一 JVM 内的线程）。

但到了微服务/分布式时代，应用部署在多台服务器上，环境变成了**公共厕所**。你家的门锁管不了别人，我们需要一个独立于所有服务器之外的“村口王大爷”来发放唯一的入场券。

这个“王大爷”，通常就是 **Redis**（基于内存，手速快）或 **ZooKeeper**（基于协议，办事稳）。

**📚 官方定义**：
> 分布式锁是通过引入外部协调器，将**并行**的流量强行转变为**串行**执行的机制，目的是保护下游资源（如数据库）不被击穿，或保证跨机环境下的数据唯一性。

---

## 二、 选型：神仙打架 (AP vs CP)

这是架构设计的第一道分水岭。你是要“快”，还是要“稳”？

| 特性 | **Redis (AP 模型 - 唯快不破)** | **ZooKeeper / Etcd (CP 模型 - 稳字当头)** |
| :--- | :--- | :--- |
| **核心人设** | **可用性优先**。极快，但在主从切换、网络抖动时可能会**丢锁**。 | **一致性优先**。基于 Paxos/Raft 协议，保证锁**绝对不丢**。 |
| **适用场景** | **99% 的互联网业务**。<br>如：抢单、秒杀、库存扣减。<br>*即便极低概率锁失效导致超卖，通常可通过客服/补偿解决。* | **金融级核心业务**。<br>如：转账、余额扣减、配置中心。<br>*对数据错误“零容忍”。* |

### 🛑 关于 Redlock 的避坑指南
你可能听说过 Redis 官方推荐的 **Redlock 算法**（多节点加锁）来解决丢锁问题。但在实战中，**我们强烈建议慎用**。
*   **原因**：算法复杂，性能损耗大，且依然依赖服务器时钟，并未彻底解决一致性问题。
*   **结论**：如果你的业务真的对“丢锁”零容忍，**请直接左转去用 ZooKeeper/Etcd**，不要在 Redis 上死磕。Redis 的宿命就是“快”，别强行让它变得“重”。

---

## 三、 实战：Redisson 黄金代码模板

在 Java 生态中，别自己造轮子去写 Redis Lua 脚本了。**Redisson** 是目前的标准答案。

### 1. 为什么要用 Redisson？(拒绝惊群效应)
如果你自己写 `while(true)` 循环重试，就像是一群人**挤在柜台前瞎嚷嚷**，锁释放的一瞬间，所有线程同时醒来抢（惊群效应），CPU 瞬间飙升。
**Redisson 的黑科技**：利用 **Pub/Sub（发布订阅）** 机制。锁释放了，才会通知等待的线程去抢。就像**银行排队叫号**，优雅且高效。

### 2. 生产级代码模板
下面是一份**生产级**的代码，包含了**异常中断处理**和**Fail-Fast**策略，可直接 Copy：

```java
@Autowired
private RedissonClient redisson;

public void executeTask(String resourceId) {
    // 1. 锁粒度控制：锁名一定要带上具体的 ID
    String lockKey = "lock:resource:" + resourceId;
    RLock lock = redisson.getLock(lockKey);

    try {
        // 2. 尝试加锁 (Fail-Fast 策略)
        // waitTime: 500ms (给线程500毫秒去抢，抢不到立刻报错，别傻等)
        // leaseTime: -1 (重点！-1 表示开启 Watchdog 看门狗自动续期)
        boolean isLocked = lock.tryLock(500, -1, TimeUnit.MILLISECONDS);
        
        if (!isLocked) {
            throw new BusinessException("哎呀，排队的人太多了，请稍后重试");
        }

        // 3. 核心业务逻辑 (Check-Then-Act)
        // 只要你业务没跑完，看门狗会每隔 10秒 帮你续命
        doBusinessLogic();

    } catch (InterruptedException e) {
        // 高级细节：恢复线程的中断状态，防止吞掉中断信号
        Thread.currentThread().interrupt();
        log.error("Lock acquisition interrupted", e);
    } finally {
        // 4. 严谨解锁：防误删
        // 必须校验：锁是否还存在？锁是不是我加的？
        if (lock.isLocked() && lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```

### 3. 🔍 锁粒度法则 (Lock Granularity)
新手最容易犯的错就是“锁太大”。
*   ❌ **错误示范**：`lock:user`（锁住了该用户的所有操作）。
*   ✅ **正确示范**：`lock:user:1001:coupon:receive`（只锁住用户 1001 领取优惠券的动作）。
**记住：** 就像去公共厕所，你只需要锁住你那个**“隔间”**的门，千万别把**“大门”**给锁了，否则会被外面排队的人打死。

---

## 四、 ⚠️ 达摩克利斯之剑：看门狗 (Watchdog) 的风险

Redisson 的看门狗机制解决了“业务没跑完，锁先过期了”的尴尬，但它也是一把**双刃剑**。

### 1. 宕机 (Crash) -> ✅ 安全
如果服务器挂了（断电、OOM），看门狗线程也挂了。Redis 里的锁会因为没人续期，在 30秒 后自动释放。**系统具备自愈能力。**

### 2. 死循环 (Infinite Loop) -> ❌ 极度危险
这是最可怕的场景：业务逻辑陷入死循环，但进程还活着。
*   **后果**：看门狗以为你还在努力工作，拼命续期。**这把锁将被永久持有 (Live Lock)。**

🛡️ **防御手段**：
1.  **业务超时控制**：在代码层面使用 `Future.get(timeout)` 强制中断超时的任务。
2.  **弃用看门狗**：对于**重型任务（如批处理、报表）**，不要用 Watchdog，直接设置明确的过期时间（如 `leaseTime = 2小时`）作为兜底。

---

## 五、 进阶：降级与兜底 (Design for Failure)

永远不要相信锁是 100% 可靠的。

1.  **SPOF 风险**：如果 Redis 挂了？
    *   **降级**：捕获异常，记录日志，然后**放行**（或降级为本地锁）。让数据库去扛最后一道防线。
2.  **最终防线：幂等性 (Idempotency)**
    *   无论锁是否失效，数据库层面的 Update 操作必须保证重复执行无副作用。这是保命的根本。

---

## 六、 终极哲学：如何“去锁化”？

这才是架构师的各种境界。**能不用锁，就别用锁。**

如果使用了分布式锁，请记住：Redis 锁在这里的作用，仅仅是作为**前置限流**，防止过多无效请求打到数据库，而不是作为数据一致性的唯一保障。

### 1. 数据库原子更新 (Atomic Update)
最适合**卡券、库存**场景。性能吊打分布式锁。

```sql
-- 即使 100 个线程同时执行，数据库行锁也会保证只有一个能扣减成功
UPDATE product_stock 
SET count = count - 1 
WHERE id = 1001 AND count > 0;
```
*利用 `Update` 的原子性和返回值（影响行数）来判断是否成功。*

### 2. 乐观锁 (Optimistic Locking)
最适合**读多写少**的复杂对象更新。

*   **玩法**：给表加个 `version` 字段。
*   **逻辑**：每次更新时，`WHERE version = 旧版本号`。如果版本号变了，说明有人插队，你可以选择报错或重试。