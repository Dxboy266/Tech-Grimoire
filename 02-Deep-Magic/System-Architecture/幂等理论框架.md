幂等的本质是：

> **同一个请求，不论被执行多少次，业务最终效果保持一致，不产生重复副作用。**  
> 幂等针对的是"请求"，不是"数据"。

> 💡 本文档为理论框架，实战代码参考：[幂等实战方案](./幂等实战方案.md)

幂等体系由三部分构成：

1. **请求身份识别（Idempotent Key）**
2. **请求执行状态记录（Idempotent Record / 幂等表）**
3. **业务执行流程中的幂等控制（状态机式执行）**

这是所有幂等模型的核心。

# 幂等键设计（Idempotent Key）

幂等键用于唯一识别一次业务动作，是幂等的根本。

## 上游 requestId（推荐）

- 由前端 / 上游系统生成
- 每一次业务操作必须产生一个唯一 requestId

## 入参哈希或摘要

如果上游无法保证唯一 则本系统生成幂等键

核心：**同请求重复 = 幂等键相同；不同请求 ≠ 幂等键。**

# 幂等表设计（Idempotent Record）

幂等记录表是"请求执行状态机"。  
幂等表不属于业务表，是**基础设施表**。

```sql
idempotent_record
  ├── id                BIGINT PK
  ├── idem_key          VARCHAR UNIQUE    # 请求唯一标识
  ├── biz_type          VARCHAR           # 业务分类（发券、扣钱、下单…）
  ├── payload_hash      VARCHAR           # 请求参数摘要（判断是否变更）
  ├── status            TINYINT           # 0处理中 / 1成功 / 2失败
  ├── result_payload    TEXT              # 用于重复请求快速返回
  ├── expire_at         DATETIME          # 幂等有效期
  ├── created_at
  └── updated_at

```

| 字段               | 功能                        |
| ------------------ | --------------------------- |
| **idem_key**       | 幂等的唯一识别（必选）      |
| **status**         | 控制并发，只能一个执行      |
| **payload_hash**   | 防止同 requestId 但参数变化 |
| **result_payload** | 重复请求直接返回            |
| **expire_at**      | 允许生命周期管理            |
| **created_at**     | 审计溯源                    |
| **updated_at**     | PROCESSING 阻塞治理         |

唯一索引 - idem_key + biz_type

### ✔ **最佳选择：领域级（Domain-level）幂等表**

- 与 DDD 分层对应
- 避免单表过大
- 各领域可以扩展自己的字段

### ✔ 系统级幂等中心（适合企业级平台）

- 强统一性
- 可跨域控制
- 表会很大，需要分库分表

# 幂等流程

```arduino
step 1: 生成/提取幂等键 idemKey

step 2: 查询幂等表
    ├── 找到 & status = 成功      → 返回 result_payload
    ├── 找到 & status = 处理中    → 返回处理中 or 拒绝重入
    └── 未找到                   → 进入下一步

step 3: 尝试插入幂等表 (status=处理中)
    ├── 成功 → 当前请求获得执行资格
    └── 唯一键冲突 → 并发重复请求，回查记录并返回

step 4: 执行业务逻辑（真正扣减/发放/写表）

step 5: 更新幂等表为成功（记录返回结果）

step 6: 返回最终结果

```

保证：

- 并发下只有一个线程执行实际业务
- 其他全部命中幂等表 → 即时返回

## 补偿 JOB

对于卡在处理中的请求，比如更新时间在 10min 前

需要定期对账，修改到成功或失败

# 参数变化问题：同 requestId 输入改变要不要覆盖？

## ✔ A. 请求级幂等（严格）——推荐

**如果 payload 改变 → 不是同一次请求 → 必须拒绝。**

核心资金类/权益类操作

严格幂等（支付、发券、扣减、订单创建等）推荐如下策略：

### payload 不同

拒绝，请重试

### 有成功记录（SUCCESS）

payload 相同返回幂等

### 有执行中记录（PROCESSING）

返回执行中

### 有失败记录（FAIL）

- 如业务"操作是不可重试的动作"：后续拒绝

- 如业务"操作具有可重试性" ：允许同 payload 再次执行

## ✔ B. 操作幂等（宽松）

场景没遇到过

参数变化可覆盖原请求，例如：

- 更新昵称
- Upsert 配置
- 重置密码

## ✔ C. 逻辑幂等 可以省略幂等表

状态机 or 版本号

返回值幂等

# 幂等表数据治理

定期清理

因为幂等记录只有"控制重入"的意义：

- 7 天对营销发券足够
- 3 天对支付类接口足够
- 30 天对消息消费足够
- 超长期会占用大量空间

# 高并发场景

Redis + MySQL 双幂等

### Step1 Redis SETNX idemKey（TTL 10-30s）

- 快速挡掉重复请求
- 不打 MySQL
- 撞 TTL 即自动释放

### Step2 MySQL 最终幂等（强一致）

- 只有 SETNX 成功的请求会写幂等表
- 唯一键保障只执行一次

优点：

- Redis 抗并发
- TTL 自动清理 Redis 冗余记录
- 强一致性由 MySQL 保证

# 分布式场景下的幂等键传递

## 核心原则

**同一个 idem_key + 细粒度 biz_type**

- **idem_key**：请求唯一标识，全链路共享
- **biz_type**：业务操作类型，区分不同动作
- **唯一约束**：`(idem_key, biz_type)` 组合唯一

## 传递规范

全链路用同一个 idem_key，通过 biz_type 区分不同操作。

## 特殊场景：需要生成新的 idem_key

- 同一 biz_type 需要多次执行：`idemKey = "req-001:item-A"`
- 跨系统隔离：`idemKey = "A:req-001"`（加前缀）

# 监控告警

```
监控指标：
- 幂等命中率（重复请求占比）
- PROCESSING 超时数量（僵尸记录）
- payload_hash 冲突次数（参数变化被拒绝）

告警规则：
- PROCESSING 超过 5min 告警
- PROCESSING 超过 10min 自动对账
- 幂等命中率突增（可能有重试风暴）
```
