# Javaå¤šçº¿ç¨‹å®æˆ˜ç²¾å

> **åŸºäº adp-agent-clue-service é¡¹ç›® | åŸç†+å®æˆ˜+å‘ç‚¹ | 5åˆ†é’Ÿé€ŸæŸ¥æ‰‹å†Œ**

---

## ğŸ“‹ å¿«é€Ÿå¯¼èˆª

**ã€æ ¸å¿ƒåŸç†ã€‘** [å¹¶å‘ä¸‰å¤§é—®é¢˜](#é›¶å¹¶å‘ç¼–ç¨‹æ ¸å¿ƒåŸç†5åˆ†é’Ÿ) | [JMMå†…å­˜æ¨¡å‹](#01-jmmå†…å­˜æ¨¡å‹) | [synchronizedåŸç†](#02-synchronizedåº•å±‚åŸç†) | [AQSåŸç†](#03-aqsæ ¸å¿ƒåŸç†)

**ã€å®æˆ˜æŠ€å·§ã€‘** [çº¿ç¨‹æ± é…ç½®](#ä¸€çº¿ç¨‹æ± å®æˆ˜) | [å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–](#äºŒå¹¶å‘å·¥å…·å®æˆ˜) | [å¼‚æ­¥äº‹ä»¶](#ä¸‰å¼‚æ­¥ç¼–ç¨‹å®æˆ˜) | [ä¸Šä¸‹æ–‡ä¼ é€’](#å››çº¿ç¨‹å®‰å…¨å®æˆ˜)

**ã€è¡€æ³ªæ•™è®­ã€‘** [OOMå‘](#å‘1executorsnewfixedthreadpool-å¯¼è‡´-oom) | [å†…å­˜æ³„æ¼å‘](#å‘2threadlocal-å†…å­˜æ³„æ¼) | [å¼‚å¸¸åæ‰å‘](#å‘3completablefuture-å¼‚å¸¸è¢«å)

**ã€æ–°æ‰‹å…¥é—¨ã€‘** [Java å¤šçº¿ç¨‹å¿«é€Ÿå…¥é—¨](./Javaå¤šçº¿ç¨‹å¿«é€Ÿå…¥é—¨.md)

---

## é›¶ã€å¹¶å‘ç¼–ç¨‹æ ¸å¿ƒåŸç†ï¼ˆ5åˆ†é’Ÿï¼‰

### 0.1 JMMå†…å­˜æ¨¡å‹

**ä¸€å¥è¯åŸç†**ï¼šæ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„å·¥ä½œå†…å­˜ï¼Œå…±äº«å˜é‡å­˜åœ¨ä¸»å†…å­˜ï¼Œçº¿ç¨‹é—´é€šè¿‡ä¸»å†…å­˜é€šä¿¡ã€‚

```
çº¿ç¨‹Aå·¥ä½œå†…å­˜ â†â†’ ä¸»å†…å­˜ â†â†’ çº¿ç¨‹Bå·¥ä½œå†…å­˜
     â†“                        â†“
  æœ¬åœ°å‰¯æœ¬                  æœ¬åœ°å‰¯æœ¬
```

**ä¸‰å¤§é—®é¢˜**ï¼š
- **åŸå­æ€§**ï¼šä¸€ä¸ªæ“ä½œä¸å¯åˆ†å‰²ï¼ˆè§£å†³æ–¹æ¡ˆï¼šsynchronizedã€Lockã€CASï¼‰
- **å¯è§æ€§**ï¼šä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹å¯è§ï¼ˆè§£å†³æ–¹æ¡ˆï¼švolatileã€synchronizedï¼‰
- **æœ‰åºæ€§**ï¼šç¦æ­¢æŒ‡ä»¤é‡æ’åºï¼ˆè§£å†³æ–¹æ¡ˆï¼šhappens-beforeè§„åˆ™ï¼‰

**happens-before æ ¸å¿ƒè§„åˆ™**ï¼ˆè®°ä½è¿™4æ¡å°±å¤Ÿäº†ï¼‰ï¼š
1. **ç¨‹åºé¡ºåºè§„åˆ™**ï¼šå•çº¿ç¨‹å†…ï¼Œä»£ç æŒ‰é¡ºåºæ‰§è¡Œ
2. **volatileè§„åˆ™**ï¼švolatileå†™ happens-before åç»­è¯»
3. **é”è§„åˆ™**ï¼šunlock happens-before åç»­lock
4. **çº¿ç¨‹å¯åŠ¨è§„åˆ™**ï¼šThread.start() happens-before çº¿ç¨‹å†…æ‰€æœ‰æ“ä½œ

---

### 0.2 synchronized åº•å±‚åŸç†

**ä¸€å¥è¯åŸç†**ï¼šé€šè¿‡å¯¹è±¡å¤´çš„ Mark Word å®ç°é”ï¼Œç»å†åå‘é”â†’è½»é‡çº§é”â†’é‡é‡çº§é”çš„å‡çº§è¿‡ç¨‹ã€‚

**å¯¹è±¡å¤´ç»“æ„**ï¼ˆ64ä½JVMï¼‰ï¼š
```
|--------------------------------------------------------------|
|  Mark Word (64 bits)  |  Class Pointer (32/64 bits)  | ...  |
|--------------------------------------------------------------|
```

**é”å‡çº§æµç¨‹**ï¼š
```
æ— é” â†’ åå‘é”ï¼ˆå•çº¿ç¨‹ï¼‰ â†’ è½»é‡çº§é”ï¼ˆCASç«äº‰ï¼‰ â†’ é‡é‡çº§é”ï¼ˆMonitoré˜»å¡ï¼‰
```

**ä¸ºä»€ä¹ˆè¦é”å‡çº§ï¼Ÿ**
- åå‘é”ï¼šå¤§éƒ¨åˆ†æƒ…å†µä¸‹é”åªè¢«ä¸€ä¸ªçº¿ç¨‹æŒæœ‰ï¼Œé¿å…CASå¼€é”€
- è½»é‡çº§é”ï¼šå¤šçº¿ç¨‹äº¤æ›¿æ‰§è¡Œï¼Œé€šè¿‡CASé¿å…é˜»å¡
- é‡é‡çº§é”ï¼šå¤šçº¿ç¨‹ç«äº‰æ¿€çƒˆï¼Œé˜»å¡ç­‰å¾…é¿å…CPUç©ºè½¬

**é¡¹ç›®å®è·µ**ï¼š
```java
// å°‘é‡ä½¿ç”¨ synchronizedï¼Œä¸»è¦ç”¨äºç®€å•åŒæ­¥
private final Map<Long, TableMapEventData> tableMapCache = new ConcurrentHashMap<>();
// é«˜å¹¶å‘åœºæ™¯ä¼˜å…ˆç”¨ ConcurrentHashMap
```

---

### 0.3 AQS æ ¸å¿ƒåŸç†

**ä¸€å¥è¯åŸç†**ï¼šAbstractQueuedSynchronizer æ˜¯ JUC çš„åŸºçŸ³ï¼Œé€šè¿‡ CLH é˜Ÿåˆ— + CAS + state å®ç°é”å’ŒåŒæ­¥å™¨ã€‚

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š
```java
// åŒæ­¥çŠ¶æ€ï¼ˆ0=æœªé”å®šï¼Œ1=é”å®šï¼‰
private volatile int state;

// CLH é˜Ÿåˆ—èŠ‚ç‚¹
static final class Node {
    volatile Node prev;  // å‰é©±
    volatile Node next;  // åç»§
    volatile Thread thread;  // ç­‰å¾…çº¿ç¨‹
}
```

**ä¸¤ç§æ¨¡å¼**ï¼š
- **ç‹¬å æ¨¡å¼**ï¼ˆExclusiveï¼‰ï¼šåŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è·å–é”ï¼ˆReentrantLockï¼‰
- **å…±äº«æ¨¡å¼**ï¼ˆSharedï¼‰ï¼šå¤šä¸ªçº¿ç¨‹å¯åŒæ—¶è·å–é”ï¼ˆCountDownLatchã€Semaphoreï¼‰

**åŸºäº AQS çš„å·¥å…·**ï¼š
| å·¥å…· | æ¨¡å¼ | é¡¹ç›®ä½¿ç”¨ |
|------|------|---------|
| ReentrantLock | ç‹¬å  | æœªä½¿ç”¨ |
| CountDownLatch | å…±äº« | æœªä½¿ç”¨ |
| Semaphore | å…±äº« | æœªä½¿ç”¨ |
| ThreadPoolExecutor | ç‹¬å  | âœ… æ ¸å¿ƒ |

---

### 0.4 CAS åŸç†ä¸åº”ç”¨

**ä¸€å¥è¯åŸç†**ï¼šCompare And Swapï¼Œé€šè¿‡ CPU åŸå­æŒ‡ä»¤å®ç°æ— é”å¹¶å‘ã€‚

**åº•å±‚å®ç°**ï¼š
```java
// Unsafe ç±»æä¾›çš„ CAS æ“ä½œ
public final native boolean compareAndSwapInt(
    Object o,      // å¯¹è±¡
    long offset,   // å†…å­˜åç§»é‡
    int expected,  // æœŸæœ›å€¼
    int x          // æ–°å€¼
);
```

**ABA é—®é¢˜**ï¼š
```
çº¿ç¨‹1ï¼šè¯»å–A â†’ å‡†å¤‡CAS
çº¿ç¨‹2ï¼šAæ”¹æˆB â†’ Bæ”¹å›A
çº¿ç¨‹1ï¼šCASæˆåŠŸï¼ˆä½†ä¸­é—´è¢«æ”¹è¿‡ï¼‰
```

**è§£å†³æ–¹æ¡ˆ**ï¼š`AtomicStampedReference`ï¼ˆå¸¦ç‰ˆæœ¬å·ï¼‰

**é¡¹ç›®å®è·µ**ï¼š
```java
// çº¿ç¨‹å·¥å‚ä¸­çš„è®¡æ•°å™¨
private final AtomicInteger counter = new AtomicInteger(1);

@Override
public Thread newThread(Runnable r) {
    Thread thread = new Thread(r, "smart-pool-" + counter.getAndIncrement());
    return thread;
}
```

---

## ä¸€ã€çº¿ç¨‹æ± å®æˆ˜

### 1.1 çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ï¼ˆå¿…é¡»ç†è§£ï¼‰

**ä¸€å¥è¯åŸç†**ï¼šæäº¤ä»»åŠ¡ â†’ åˆ¤æ–­æ ¸å¿ƒçº¿ç¨‹ â†’ åˆ¤æ–­é˜Ÿåˆ— â†’ åˆ¤æ–­æœ€å¤§çº¿ç¨‹ â†’ æ‰§è¡Œæ‹’ç»ç­–ç•¥

```
æäº¤ä»»åŠ¡
  â†“
å½“å‰çº¿ç¨‹æ•° < corePoolSizeï¼Ÿ
  â”œâ”€ æ˜¯ â†’ åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
  â””â”€ å¦ â†’ é˜Ÿåˆ—æœªæ»¡ï¼Ÿ
           â”œâ”€ æ˜¯ â†’ ä»»åŠ¡å…¥é˜Ÿ
           â””â”€ å¦ â†’ å½“å‰çº¿ç¨‹æ•° < maximumPoolSizeï¼Ÿ
                    â”œâ”€ æ˜¯ â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
                    â””â”€ å¦ â†’ æ‰§è¡Œæ‹’ç»ç­–ç•¥
```

---

### 1.2 çº¿ç¨‹æ± å‚æ•°é…ç½®å†³ç­–è¡¨

**å¿«é€Ÿå†³ç­–**ï¼šæ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©å‚æ•°

| ä»»åŠ¡ç±»å‹ | æ ¸å¿ƒçº¿ç¨‹æ•° | æœ€å¤§çº¿ç¨‹æ•° | é˜Ÿåˆ—å®¹é‡ | æ‹’ç»ç­–ç•¥ | é¡¹ç›®å®è·µ |
|---------|-----------|-----------|---------|---------|---------|
| **CPUå¯†é›†** | N+1 | N+1 | å°(1000) | CallerRuns | calcExecutor |
| **IOå¯†é›†** | 2N | 2N~4N | å¤§(10ä¸‡) | Abort | clueExecutor |
| **æ··åˆå‹** | 8N | 16N | ä¸­(1000) | CallerRuns | smartExecutor |

**å…¬å¼æ¨å¯¼**ï¼š
- N = CPUæ ¸å¿ƒæ•°ï¼ˆ`Runtime.getRuntime().availableProcessors()`ï¼‰
- IOå¯†é›†å‹ï¼šçº¿ç¨‹æ•° = N Ã— (1 + WT/ST)ï¼ŒWT=ç­‰å¾…æ—¶é—´ï¼ŒST=è®¡ç®—æ—¶é—´

---

### 1.3 é¡¹ç›®ä¸­çš„3ä¸ªçº¿ç¨‹æ± 

#### â‘  smartExecutor - é€šç”¨çº¿ç¨‹æ± ï¼ˆåŠ¨æ€æ‰©ç¼©å®¹ï¼‰

```java
@Bean(name = "smartExecutor")
public Executor smartExecutor() {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(
        CPU_COUNT * 8,   // æ ¸å¿ƒçº¿ç¨‹
        CPU_COUNT * 16,  // æœ€å¤§çº¿ç¨‹
        60L, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(1000),
        new ThreadFactory() {
            private final AtomicInteger counter = new AtomicInteger(1);
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, "smart-pool-" + counter.getAndIncrement());
                t.setUncaughtExceptionHandler((thread, e) ->
                    log.error("Thread [{}] error", thread.getName(), e));
                return t;
            }
        },
        new ThreadPoolExecutor.CallerRunsPolicy()
    );

    return TtlExecutors.getTtlExecutor(executor);  // TTLåŒ…è£…
}
```

**é…ç½®å‚æ•°åŒ–**ï¼š
```yaml
thread-pool:
  coreSizeMultiple: 8
  maxSizeMultiple: 16
  queueCapacity: 1000
```

---

#### â‘¡ clueExecutor - çº¿ç´¢å¤„ç†çº¿ç¨‹æ± ï¼ˆé«˜ååï¼‰

```java
@Bean("clueExecutor")
public Executor clueExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(CPU_COUNT * 2);
    executor.setMaxPoolSize(CPU_COUNT * 4);
    executor.setQueueCapacity(100000);  // å¤§é˜Ÿåˆ—ç¼“å†²çªå‘æµé‡
    executor.setThreadNamePrefix("clueExecutor-");
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
    executor.setWaitForTasksToCompleteOnShutdown(true);
    executor.setAwaitTerminationSeconds(30);
    executor.initialize();
    return TtlExecutors.getTtlExecutor(executor);
}
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- å¼‚æ­¥äº‹ä»¶ç›‘å¬ï¼ˆ`@Async("clueExecutor")`ï¼‰
- æ¶ˆæ¯é˜Ÿåˆ—æ¶ˆè´¹
- çº¿ç´¢åˆ›å»ºé€šçŸ¥

---

#### â‘¢ taskExecutor - é€šç”¨ä»»åŠ¡çº¿ç¨‹æ± 

```java
@Bean
public Executor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(CPU_COUNT * 2);
    executor.setMaxPoolSize(CPU_COUNT * 2);
    executor.setQueueCapacity(1000);
    executor.setThreadNamePrefix("task-");
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
    executor.initialize();
    return TtlExecutors.getTtlExecutor(executor);
}
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- ç”¨æˆ·æ—…ç¨‹æµæ°´ä¿®å¤ï¼ˆ`CompletableFuture.runAsync(task, taskExecutor)`ï¼‰
- æ‰¹é‡æ•°æ®å¤„ç†

---

### 1.4 å››ç§æ‹’ç»ç­–ç•¥é€‰æ‹©

| æ‹’ç»ç­–ç•¥ | è¡Œä¸º | ä¼˜ç‚¹ | ç¼ºç‚¹ | é¡¹ç›®ä½¿ç”¨ |
|---------|------|------|------|---------|
| **AbortPolicy** | æŠ›å¼‚å¸¸ | å¿«é€Ÿå¤±è´¥ | éœ€æ•è·å¼‚å¸¸ | clueExecutor |
| **CallerRunsPolicy** | è°ƒç”¨è€…æ‰§è¡Œ | è‡ªåŠ¨é™é€Ÿ | é˜»å¡è°ƒç”¨çº¿ç¨‹ | smartExecutor |
| **DiscardPolicy** | é™é»˜ä¸¢å¼ƒ | ä¸é˜»å¡ | ä»»åŠ¡ä¸¢å¤± | æœªä½¿ç”¨ |
| **DiscardOldestPolicy** | ä¸¢å¼ƒæœ€è€ | ä¿è¯æœ€æ–° | è€ä»»åŠ¡ä¸¢å¤± | æœªä½¿ç”¨ |

---

### 1.5 è¡€æ³ªæ•™è®­ï¼šçº¿ç¨‹æ± çš„3ä¸ªè‡´å‘½å‘

#### å‘1ï¼š`Executors.newFixedThreadPool()` å¯¼è‡´ OOM

**ç°è±¡**ï¼šç”Ÿäº§ç¯å¢ƒå†…å­˜æº¢å‡ºï¼Œå †å†…å­˜å ç”¨æŒç»­å¢é•¿

**åŸå› **ï¼š
```java
// Executors æºç 
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>());  // é˜Ÿåˆ—å®¹é‡ = Integer.MAX_VALUE
}
```

**æ•™è®­**ï¼š
- âŒ ç¦æ­¢ä½¿ç”¨ `Executors` åˆ›å»ºçº¿ç¨‹æ± 
- âœ… æ‰‹åŠ¨åˆ›å»º `ThreadPoolExecutor`ï¼Œæ˜ç¡®é˜Ÿåˆ—å®¹é‡

---

#### å‘2ï¼šçº¿ç¨‹æ± æ²¡æœ‰å‘½å

**ç°è±¡**ï¼šçº¿ç¨‹ dump çœ‹ä¸å‡ºå“ªä¸ªä¸šåŠ¡ï¼Œæ’æŸ¥é—®é¢˜å›°éš¾

**åŸå› **ï¼šé»˜è®¤çº¿ç¨‹å `pool-1-thread-1`ï¼Œæ— æ³•åŒºåˆ†ä¸šåŠ¡

**æ•™è®­**ï¼š
```java
// âŒ é”™è¯¯
new ThreadPoolExecutor(...);

// âœ… æ­£ç¡®
executor.setThreadNamePrefix("clueExecutor-");
```

---

#### å‘3ï¼šæ²¡æœ‰è®¾ç½®æ‹’ç»ç­–ç•¥

**ç°è±¡**ï¼šä»»åŠ¡é™é»˜ä¸¢å¤±ï¼Œä¸šåŠ¡æ•°æ®ä¸ä¸€è‡´

**åŸå› **ï¼šé»˜è®¤ `AbortPolicy` æŠ›å¼‚å¸¸ä½†æ²¡æ•è·

**æ•™è®­**ï¼šæ ¹æ®ä¸šåŠ¡é€‰æ‹©åˆé€‚çš„æ‹’ç»ç­–ç•¥
- å…³é”®ä¸šåŠ¡ï¼š`AbortPolicy`ï¼ˆæŠ›å¼‚å¸¸ï¼‰
- é™é€Ÿä¿æŠ¤ï¼š`CallerRunsPolicy`ï¼ˆè°ƒç”¨è€…æ‰§è¡Œï¼‰

---

## äºŒã€å¹¶å‘å·¥å…·å®æˆ˜

### 2.1 CompletableFuture å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

**ä¸€å¥è¯åŸç†**ï¼šå°†ä¸²è¡ŒæŸ¥è¯¢æ”¹ä¸ºå¹¶è¡ŒæŸ¥è¯¢ï¼Œæ€§èƒ½æå‡ N å€ï¼ˆN = æŸ¥è¯¢æ•°é‡ï¼‰

**æ ¸å¿ƒå·¥å…·ç±»**ï¼š`ParallelExecutorUtils`

```java
@Component
public class ParallelExecutorUtils {

    private static Executor staticExecutor;

    @Autowired
    private Executor smartExecutor;

    @PostConstruct
    public void init() {
        staticExecutor = this.smartExecutor;
    }

    /**
     * å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡
     * å¼ºçº¦å®šï¼šä»»åŠ¡ä¸èƒ½è¿”å› null
     */
    public static <T> List<T> execute(Callable<T>... tasks) throws Exception {
        List<CompletableFuture<T>> futures = new ArrayList<>();

        // 1. æäº¤æ‰€æœ‰ä»»åŠ¡
        for (Callable<T> task : tasks) {
            CompletableFuture<T> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return task.call();
                } catch (Exception e) {
                    throw new CompletionException(e);  // åŒ…è£…å¼‚å¸¸
                }
            }, staticExecutor);
            futures.add(future);
        }

        // 2. ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();

        // 3. æ”¶é›†ç»“æœ
        List<T> results = new ArrayList<>();
        for (CompletableFuture<T> future : futures) {
            results.add(future.get());
        }
        return results;
    }

    /**
     * å¹¶è¡Œæ‰§è¡Œ + åç½®å¤„ç†
     */
    public static <T, M> M executeFunction(
            MyBusinessLogicFunction<T, M> function,
            Object[] param,
            Callable<T>... tasks) throws Exception {

        List<T> results = execute(staticExecutor, tasks);
        return (M) function.myselfBusinessLogic(results, param);
    }
}
```

---

### 2.2 å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç´¢è¯¦æƒ…å¹¶è¡ŒæŸ¥è¯¢

**ä¼˜åŒ–å‰ï¼ˆä¸²è¡ŒæŸ¥è¯¢ï¼‰**ï¼š
```java
// è€—æ—¶ï¼š5ç§’ï¼ˆ5ä¸ªæŸ¥è¯¢å„1ç§’ï¼‰
SacClueInfoDlr clue = clueDlrService.getEntity(clueBO);           // 1s
SacReviewBO review = reviewService.getReviewInfo(vrBO);           // 1s
SacOnecustInfoEntity custInfo = oneCustInfoService.getEntity();   // 1s
SacUserGroupDetailEntity userGroup = userGroupDetailService.get();// 1s
SacOneCustRemark remark = oneCustRemarkService.queryRemark();     // 1s
```

**ä¼˜åŒ–åï¼ˆå¹¶è¡ŒæŸ¥è¯¢ï¼‰**ï¼š
```java
// è€—æ—¶ï¼š1ç§’ï¼ˆæ€§èƒ½æå‡ 5 å€ï¼‰
ClueDlrDetailRspVO result = ParallelExecutorUtils.executeFunction(
    this::conventDetailRsp,  // ç»“æœè½¬æ¢å‡½æ•°
    null,

    // 5ä¸ªæŸ¥è¯¢å¹¶è¡Œæ‰§è¡Œ
    () -> Optional.ofNullable(clueDlrService.getEntity(clueBO, columnsDlr))
                 .orElse(new SacClueInfoDlr()),
    () -> Optional.ofNullable(reviewService.getReviewInfo(vrBO, columnsReview))
                 .orElse(new SacReviewBO()),
    () -> Optional.ofNullable(oneCustInfoService.getEntity(custBoObj, columnsCustInfo))
                 .orElse(new SacOnecustInfoEntity()),
    () -> Optional.ofNullable(userGroupDetailService.getEntity(userGroupBO))
                 .orElse(new SacUserGroupDetailEntity()),
    () -> Optional.ofNullable(oneCustRemarkService.queryRemark(custRemark))
                 .orElse(new SacOneCustRemark())
);

// ç»“æœè½¬æ¢å‡½æ•°
private ClueDlrDetailRspVO conventDetailRsp(List<Object> results, Object[] params) {
    return ClueDlrDetailRspVO.builder()
        .clueInfo((SacClueInfoDlr) results.get(0))
        .reviewInfo((SacReviewBO) results.get(1))
        .custInfo((SacOnecustInfoEntity) results.get(2))
        .userGroup((SacUserGroupDetailEntity) results.get(3))
        .remark((SacOneCustRemark) results.get(4))
        .build();
}
```

**æ€§èƒ½æ•°æ®**ï¼š
- ä¸²è¡ŒæŸ¥è¯¢ï¼š5ç§’
- å¹¶è¡ŒæŸ¥è¯¢ï¼š1ç§’
- **æ€§èƒ½æå‡ï¼š5å€**

---

### 2.3 ForkJoinPool å¤§æ•°æ®é‡åˆ†æ²»

**ä¸€å¥è¯åŸç†**ï¼šå°†å¤§ä»»åŠ¡é€’å½’æ‹†åˆ†æˆå°ä»»åŠ¡ï¼Œå¹¶è¡Œæ‰§è¡Œååˆå¹¶ç»“æœï¼ˆåˆ†æ²»ç®—æ³•ï¼‰

**æ ¸å¿ƒå·¥å…·ç±»**ï¼š`ForkJoinUtil`

```java
public class ForkJoinUtil<T1, T2> extends RecursiveTask<List<T2>> {

    private List<T1> pendList;              // å¾…å¤„ç†é›†åˆ
    private SelfLogicForkJoinFunction<T1, T2> function;  // å¤„ç†å‡½æ•°
    private Integer maxSize = 1000;         // åˆ†ç‰‡é˜ˆå€¼

    @Override
    protected List<T2> compute() {
        // å°äºé˜ˆå€¼ï¼Œç›´æ¥è®¡ç®—
        if (pendList.size() <= maxSize) {
            return function.selfLogicForkJoinFunction(pendList, params);
        }

        // å¤§äºé˜ˆå€¼ï¼Œåˆ†æ²»å¤„ç†
        int mid = pendList.size() / 2;
        ForkJoinUtil<T1, T2> leftTask = new ForkJoinUtil<>(
            pendList.subList(0, mid), maxSize, function, params);
        ForkJoinUtil<T1, T2> rightTask = new ForkJoinUtil<>(
            pendList.subList(mid, pendList.size()), maxSize, function, params);

        // å¼‚æ­¥æ‰§è¡Œ
        leftTask.fork();
        rightTask.fork();

        // åˆå¹¶ç»“æœ
        List<T2> result = new ArrayList<>();
        result.addAll(leftTask.join());
        result.addAll(rightTask.join());
        return result;
    }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```java
// 10ä¸‡æ¡æ•°æ®æ‰¹é‡å¤„ç†
ForkJoinPool pool = new ForkJoinPool();
ForkJoinUtil<DataDTO, ResultDTO> task = new ForkJoinUtil<>(
    dataList,           // 10ä¸‡æ¡æ•°æ®
    1000,              // æ¯æ‰¹1000æ¡
    this::processData  // å¤„ç†å‡½æ•°
);
List<ResultDTO> results = pool.invoke(task);
```

**é€‚ç”¨åœºæ™¯**ï¼š
- å¤§é›†åˆæ‰¹é‡å¤„ç†ï¼ˆ10ä¸‡+æ•°æ®ï¼‰
- é€’å½’è®¡ç®—ï¼ˆæ ‘å½¢ç»“æ„éå†ï¼‰
- æ•°æ®èšåˆï¼ˆMapReduceï¼‰

---

### 2.4 CompletableFuture æ ¸å¿ƒ API é€ŸæŸ¥

| API | ä½œç”¨ | è¿”å›å€¼ | ä½¿ç”¨åœºæ™¯ |
|-----|------|--------|---------|
| `supplyAsync()` | å¼‚æ­¥æ‰§è¡Œæœ‰è¿”å›å€¼ä»»åŠ¡ | `CompletableFuture<T>` | æŸ¥è¯¢æ•°æ® |
| `runAsync()` | å¼‚æ­¥æ‰§è¡Œæ— è¿”å›å€¼ä»»åŠ¡ | `CompletableFuture<Void>` | åˆ é™¤æ•°æ® |
| `thenApply()` | ç»“æœè½¬æ¢ | `CompletableFuture<U>` | æ•°æ®è½¬æ¢ |
| `thenAccept()` | ç»“æœæ¶ˆè´¹ | `CompletableFuture<Void>` | æ‰“å°æ—¥å¿— |
| `thenCombine()` | ç»„åˆä¸¤ä¸ªFuture | `CompletableFuture<V>` | åˆå¹¶ç»“æœ |
| `allOf()` | ç­‰å¾…æ‰€æœ‰å®Œæˆ | `CompletableFuture<Void>` | å¹¶è¡ŒæŸ¥è¯¢ |
| `anyOf()` | ä»»æ„ä¸€ä¸ªå®Œæˆ | `CompletableFuture<Object>` | è¶…æ—¶æ§åˆ¶ |
| `exceptionally()` | å¼‚å¸¸å¤„ç† | `CompletableFuture<T>` | è¿”å›é»˜è®¤å€¼ |
| `handle()` | ç»Ÿä¸€å¤„ç†æˆåŠŸ/å¤±è´¥ | `CompletableFuture<U>` | å¼‚å¸¸è½¬æ¢ |
| `whenComplete()` | å®Œæˆåå›è°ƒ | `CompletableFuture<T>` | è®°å½•æ—¥å¿— |

**ç¤ºä¾‹**ï¼š
```java
// 1. åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "result", executor);

// 2. ç»“æœè½¬æ¢
future.thenApply(s -> s.length());

// 3. å¼‚å¸¸å¤„ç†
future.exceptionally(ex -> {
    log.error("Error", ex);
    return "default";
});

// 4. ç­‰å¾…æ‰€æœ‰å®Œæˆ
CompletableFuture.allOf(future1, future2, future3).join();
```

---

## ä¸‰ã€å¼‚æ­¥ç¼–ç¨‹å®æˆ˜

### 3.1 Spring @Async å¼‚æ­¥äº‹ä»¶

**ä¸€å¥è¯åŸç†**ï¼šé€šè¿‡ `@Async` æ³¨è§£å°†æ–¹æ³•å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ä¸»æµç¨‹

**å¯ç”¨å¼‚æ­¥æ”¯æŒ**ï¼š
```java
@EnableAsync
@SpringBootApplication
public class MainApplication {}
```

**å®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç´¢åˆ›å»ºå¼‚æ­¥é€šçŸ¥**

```java
@Slf4j
@Component
public class AgentClueCreateEventListener
        implements ApplicationListener<AgentClueCreateEvent> {

    @Autowired
    private AgentDlrCreateCluePublisher publisher;

    @Override
    @Async("clueExecutor")  // æŒ‡å®šçº¿ç¨‹æ± 
    public void onApplicationEvent(AgentClueCreateEvent event) {
        // 1. å‚æ•°æ ¡éªŒ
        if (event == null || event.getAgentClueSaveDTO() == null) {
            log.warn("event is null");
            return;
        }

        try {
            // 2. ä¸šåŠ¡å¤„ç†
            AgentClueSaveDTO dto = event.getAgentClueSaveDTO();
            CreateClueMessage message = BeanUtils.copyProperties(dto, CreateClueMessage.class);
            publisher.sendClueCreateMessage(JSONUtil.toJsonStr(message));
            log.info("Clue message sent for phone: {}", message.getPhone());
        } catch (Exception e) {
            // 3. å¼‚å¸¸å¤„ç†ï¼ˆä¸å½±å“ä¸»æµç¨‹ï¼‰
            log.error("Failed to process event", e);
        }
    }
}
```

**@Async æ³¨æ„äº‹é¡¹**ï¼š
1. âœ… æ–¹æ³•å¿…é¡»æ˜¯ `public`
2. âœ… å¿…é¡»æŒ‡å®šçº¿ç¨‹æ± ï¼ˆ`@Async("clueExecutor")`ï¼‰
3. âŒ ä¸èƒ½åœ¨åŒä¸€ä¸ªç±»å†…éƒ¨è°ƒç”¨ï¼ˆAOPä»£ç†å¤±æ•ˆï¼‰
4. âœ… è¿”å›å€¼å»ºè®®ç”¨ `CompletableFuture`

---

### 3.2 CompletableFuture å¤šé˜¶æ®µç¼–æ’

**å®æˆ˜æ¡ˆä¾‹ï¼šç”¨æˆ·æ—…ç¨‹æµæ°´ä¿®å¤**

**ä¸šåŠ¡æµç¨‹**ï¼š
```
é˜¶æ®µ1ï¼šå¹¶è¡Œåˆ é™¤æ—§æ•°æ®
  â†“
é˜¶æ®µ2ï¼šå¹¶è¡ŒæŸ¥è¯¢3ä¸ªæ•°æ®æºï¼ˆç®€å†ã€è¯•é©¾ã€è®¢å•ï¼‰
  â†“
é˜¶æ®µ3ï¼šåˆ†ç‰‡å¹¶è¡Œè®¡ç®—ï¼ˆæ¯æ‰¹1000æ¡ï¼‰
  â†“
é˜¶æ®µ4ï¼šèšåˆç»“æœæ‰¹é‡æ’å…¥
```

**ä»£ç å®ç°**ï¼š
```java
public void flowFix(List<SacClueInfoDlr> clues) {
    List<String> custIds = clues.stream()
                                .map(SacClueInfoDlr::getCustId)
                                .collect(Collectors.toList());

    // é˜¶æ®µ1ï¼šå¹¶è¡Œåˆ é™¤æ—§æ•°æ®
    CompletableFuture<Void> flowsFuture =
        CompletableFuture.runAsync(() -> deleteFlows(custIds), taskExecutor);

    // é˜¶æ®µ2ï¼šå¹¶è¡ŒæŸ¥è¯¢3ä¸ªæ•°æ®æº
    CompletableFuture<Map<String, List<SacOnecustResumeVO>>> resumesFuture =
        CompletableFuture.supplyAsync(() -> getResumesMap(custIds), taskExecutor);
    CompletableFuture<Map<String, List<DriveDTO>>> drivesFuture =
        CompletableFuture.supplyAsync(() -> getDrivesMap(custIds), taskExecutor);
    CompletableFuture<Map<String, List<OrderDTO>>> ordersFuture =
        CompletableFuture.supplyAsync(() -> getOrdersMap(custIds), taskExecutor);

    // é˜¶æ®µ3ï¼šç­‰å¾…æ‰€æœ‰æŸ¥è¯¢å®Œæˆåï¼Œåˆ†ç‰‡å¹¶è¡Œè®¡ç®—
    CompletableFuture.allOf(flowsFuture, resumesFuture, drivesFuture, ordersFuture)
        .thenAccept(v -> {
            try {
                // è·å–æŸ¥è¯¢ç»“æœ
                Map<String, List<SacOnecustResumeVO>> resumesMap = resumesFuture.get();
                Map<String, List<DriveDTO>> drivesMap = drivesFuture.get();
                Map<String, List<OrderDTO>> ordersMap = ordersFuture.get();

                // åˆ†ç‰‡å¹¶è¡Œè®¡ç®—ï¼ˆæ¯æ‰¹1000æ¡ï¼‰
                List<CompletableFuture<List<CustEventFlow>>> calcTasks = new ArrayList<>();
                for (List<SacClueInfoDlr> list : Lists.partition(clues, 1000)) {
                    calcTasks.add(CompletableFuture.supplyAsync(
                        () -> calcFlows(list, resumesMap, drivesMap, ordersMap),
                        calcExecutor));
                }

                // é˜¶æ®µ4ï¼šèšåˆæ‰€æœ‰è®¡ç®—ç»“æœ
                List<CustEventFlow> insertFlows =
                    CompletableFuture.allOf(calcTasks.toArray(new CompletableFuture[0]))
                        .thenApply(subV -> calcTasks.stream()
                                                   .map(CompletableFuture::join)
                                                   .flatMap(Collection::stream)
                                                   .collect(Collectors.toList()))
                        .get();

                // æ‰¹é‡æ’å…¥
                if (CollectionUtil.isNotEmpty(insertFlows)) {
                    batchInsertFlows(insertFlows);
                }
            } catch (Exception e) {
                log.error("flow fix exception", e);
            }
        })
        .exceptionally(ex -> {
            log.error("flow fix exception", ex);
            return null;
        });
}
```

**å…³é”®ç‚¹**ï¼š
1. `runAsync()` - æ— è¿”å›å€¼ä»»åŠ¡ï¼ˆåˆ é™¤ï¼‰
2. `supplyAsync()` - æœ‰è¿”å›å€¼ä»»åŠ¡ï¼ˆæŸ¥è¯¢ï¼‰
3. `allOf()` - ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
4. `thenAccept()` - æ¶ˆè´¹ç»“æœ
5. `exceptionally()` - å¼‚å¸¸å¤„ç†

---

## å››ã€çº¿ç¨‹å®‰å…¨å®æˆ˜

### 4.1 ThreadLocal å†…å­˜æ³„æ¼é—®é¢˜

**ä¸€å¥è¯åŸç†**ï¼šThreadLocal çš„ key æ˜¯å¼±å¼•ç”¨ï¼ŒGC å key=null ä½† value ä»å­˜åœ¨ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼

**å†…å­˜æ³„æ¼åŸç†**ï¼š
```
Thread â†’ ThreadLocalMap â†’ Entry(WeakReference<ThreadLocal>, value)
                              â†“
                         ThreadLocalè¢«GC
                              â†“
                         key = null, valueä»å­˜åœ¨
                              â†“
                         å†…å­˜æ³„æ¼
```

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨åå¿…é¡» `remove()`

```java
try {
    UserInfoContext.set(user);
    // ä¸šåŠ¡é€»è¾‘
} finally {
    UserInfoContext.remove();  // é˜²æ­¢å†…å­˜æ³„æ¼
}
```

---

### 4.2 TransmittableThreadLocal ä¸Šä¸‹æ–‡ä¼ é€’

**é—®é¢˜**ï¼šæ™®é€š ThreadLocal åœ¨çº¿ç¨‹æ± ä¸­å¤±æ•ˆ

```java
// âŒ é”™è¯¯ï¼šå­çº¿ç¨‹è·å–ä¸åˆ°
ThreadLocal<String> userContext = new ThreadLocal<>();
userContext.set("user123");
executor.submit(() -> {
    String user = userContext.get();  // null
});
```

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é˜¿é‡Œ TTL

**â‘  å¼•å…¥ä¾èµ–**ï¼š
```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>transmittable-thread-local</artifactId>
</dependency>
```

**â‘¡ å®šä¹‰ä¸Šä¸‹æ–‡**ï¼š
```java
public class UserInfoContext {

    private static final TransmittableThreadLocal<UserBusiEntity> USER_INFO_TTL =
        new TransmittableThreadLocal<UserBusiEntity>() {
            @Override
            protected UserBusiEntity initialValue() {
                throw new BusinessException("ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•åé‡è¯•ï¼");
            }
        };

    public static UserBusiEntity get() {
        return USER_INFO_TTL.get();
    }

    public static void set(UserBusiEntity user) {
        USER_INFO_TTL.set(user);
    }

    public static void remove() {
        USER_INFO_TTL.remove();
    }
}
```

**â‘¢ åŒ…è£…çº¿ç¨‹æ± **ï¼š
```java
@Bean("clueExecutor")
public Executor clueExecutor() {
    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
    taskExecutor.setCorePoolSize(CPU_COUNT * 2);
    taskExecutor.initialize();

    // å…³é”®ï¼šä½¿ç”¨TTLåŒ…è£…
    return TtlExecutors.getTtlExecutor(taskExecutor);
}
```

---

### 4.3 å¹¶å‘å®‰å…¨å·¥å…·é€‰æ‹©

| åœºæ™¯ | å·¥å…· | æ€§èƒ½ | é¡¹ç›®ä½¿ç”¨ |
|------|------|------|---------|
| ç®€å•åŒæ­¥ | `synchronized` | ä½ | å°‘é‡ä½¿ç”¨ |
| å¯ä¸­æ–­é” | `ReentrantLock` | ä¸­ | æœªä½¿ç”¨ |
| é«˜å¹¶å‘Map | `ConcurrentHashMap` | é«˜ | âœ… BinlogListenerç¼“å­˜ |
| è®¡æ•°å™¨ | `AtomicInteger` | é«˜ | âœ… çº¿ç¨‹å·¥å‚è®¡æ•°å™¨ |
| çº¿ç¨‹éš”ç¦» | `ThreadLocal` | æœ€é«˜ | âœ… UserInfoContext |

**é¡¹ç›®å®è·µ**ï¼š
```java
// 1. åŸå­ç±» - çº¿ç¨‹è®¡æ•°å™¨
private final AtomicInteger counter = new AtomicInteger(1);

// 2. ConcurrentHashMap - è¡¨æ˜ å°„ç¼“å­˜
private final Map<Long, TableMapEventData> tableMapCache = new ConcurrentHashMap<>();

// 3. TransmittableThreadLocal - ç”¨æˆ·ä¸Šä¸‹æ–‡
private static final TransmittableThreadLocal<UserBusiEntity> USER_INFO_TTL =
    new TransmittableThreadLocal<>();
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–å®æˆ˜

### 5.1 æ‰¹å¤„ç†ä¼˜åŒ–

**ä¸€å¥è¯åŸç†**ï¼šå¤§æ•°æ®é‡åˆ†ç‰‡å¤„ç†ï¼Œé¿å… OOM + æ§åˆ¶æ•°æ®åº“å‹åŠ› + æé«˜å¹¶å‘åº¦

**æ ¸å¿ƒå·¥å…·**ï¼š`Lists.partition()`

```java
/**
 * æ‰¹é‡å¤„ç†æœ€ä½³å®è·µ
 */
public void batchProcess(List<Long> ids) {
    if (CollectionUtil.isEmpty(ids)) {
        return;
    }

    // æ¯æ‰¹1000æ¡
    List<List<Long>> partitions = Lists.partition(ids, 1000);

    // å¹¶è¡Œå¤„ç†æ¯æ‰¹æ•°æ®
    List<CompletableFuture<Void>> futures = partitions.stream()
        .map(batch -> CompletableFuture.runAsync(() -> {
            processBatch(batch);
        }, taskExecutor))
        .collect(Collectors.toList());

    // ç­‰å¾…æ‰€æœ‰æ‰¹æ¬¡å®Œæˆ
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
}

private void processBatch(List<Long> batch) {
    // æ‰¹é‡æŸ¥è¯¢
    List<Entity> entities = entityMapper.selectBatchIds(batch);
    // æ‰¹é‡æ›´æ–°
    entityMapper.updateBatchById(entities);
}
```

**é¡¹ç›®å®è·µ**ï¼š
```java
// ç”¨æˆ·æ—…ç¨‹æµæ°´ä¿®å¤ - åˆ†æ‰¹å¤„ç†
for (List<SacClueInfoDlr> list : Lists.partition(clues, 1000)) {
    userJourneysHelper.flowFix(list);
}
```

---

### 5.2 æ…¢æŸ¥è¯¢ä¼˜åŒ–ï¼ˆå¤ç”¨ 2.2 æ¡ˆä¾‹ï¼‰

è¿™ä¸€èŠ‚æœ¬è´¨ä¸Šå°±æ˜¯ **2.2ã€Œçº¿ç´¢è¯¦æƒ…å¹¶è¡ŒæŸ¥è¯¢ã€çš„æ€§èƒ½å¤ç›˜**ï¼Œä¸å†é‡å¤è´´ä¸€éä»£ç ï¼Œåªå¼ºè°ƒç»“è®ºå’Œä½¿ç”¨å‡†åˆ™ã€‚

**ç»“è®º**ï¼š
- åŸå®ç°ï¼š5 ä¸ªè¿œç¨‹/DB æŸ¥è¯¢ä¸²è¡Œæ‰§è¡Œï¼Œæ€»è€—æ—¶ â‰ˆ **5s**ï¼›
- ä¼˜åŒ–åï¼šç”¨ `CompletableFuture` + `ParallelExecutorUtils` å¹¶è¡Œæ‰§è¡Œï¼Œæ€»è€—æ—¶ â‰ˆ **1s**ï¼›
- åœ¨çº¿ç´¢è¯¦æƒ…è¿™ç§ã€Œå¤šæ•°æ®æºèšåˆã€åœºæ™¯ï¼Œ**èƒ½å¹¶è¡Œçš„ä¸€å¾‹å¹¶è¡Œ**ï¼Œä¸éœ€è¦ä»»ä½•ç„å­¦ä¼˜åŒ–ã€‚

**ä½¿ç”¨å‡†åˆ™**ï¼š
1. æŸ¥è¯¢ä¹‹é—´**æ²¡æœ‰å¼ºä¾èµ–**ï¼ˆäº’ä¸éœ€è¦å¯¹æ–¹ç»“æœï¼‰æ—¶ï¼Œä¼˜å…ˆå¹¶è¡Œï¼›
2. ä½¿ç”¨é¡¹ç›®å†…å°è£…å¥½çš„ `ParallelExecutorUtils`ï¼Œ**ç»Ÿä¸€å¼‚å¸¸å¤„ç†å’Œçº¿ç¨‹æ± ç®¡ç†**ï¼›
3. ç»“æœèšåˆé€»è¾‘æ”¾åˆ°ä¸€ä¸ªä¸“é—¨çš„è½¬æ¢å‡½æ•°é‡Œï¼Œä¿è¯**ä¸šåŠ¡é€»è¾‘åªå†™ä¸€éã€ç»“æ„æ¸…æ™°**ï¼›
4. è¯¦ç»†ä»£ç å’Œå®Œæ•´ç¤ºä¾‹ï¼Œè§ä¸Šæ–‡ **2.2ã€Œå®æˆ˜æ¡ˆä¾‹ï¼šçº¿ç´¢è¯¦æƒ…å¹¶è¡ŒæŸ¥è¯¢ã€**ã€‚

---

### 5.3 æ€§èƒ½ä¼˜åŒ–æ¸…å•

- [x] ä¸²è¡Œæ”¹å¹¶è¡Œï¼šä½¿ç”¨ CompletableFuture
- [x] å¤§é›†åˆåˆ†ç‰‡ï¼šä½¿ç”¨ Lists.partition
- [x] æ‰¹é‡æ“ä½œï¼šå‡å°‘æ•°æ®åº“äº¤äº’
- [x] å¼‚æ­¥è§£è€¦ï¼šä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—
- [ ] ç¼“å­˜ä¼˜åŒ–ï¼šä½¿ç”¨ Redis
- [ ] çº¿ç¨‹æ± ç›‘æ§ï¼šå®šæ—¶è¾“å‡ºæŒ‡æ ‡
- [x] æ…¢æŸ¥è¯¢ä¼˜åŒ–ï¼šå¹¶è¡ŒæŸ¥è¯¢å¤šæ•°æ®æº

---

## å…­ã€è¡€æ³ªæ•™è®­æ±‡æ€»

### å‘1ï¼š`Executors.newFixedThreadPool()` å¯¼è‡´ OOM

**ç°è±¡**ï¼šç”Ÿäº§ç¯å¢ƒå†…å­˜æº¢å‡º

**åŸå› **ï¼šé˜Ÿåˆ—å®¹é‡ = `Integer.MAX_VALUE`

**æ•™è®­**ï¼š
- âŒ ç¦æ­¢ä½¿ç”¨ `Executors` åˆ›å»ºçº¿ç¨‹æ± 
- âœ… æ‰‹åŠ¨åˆ›å»º `ThreadPoolExecutor`ï¼Œæ˜ç¡®é˜Ÿåˆ—å®¹é‡

---

### å‘2ï¼šThreadLocal å†…å­˜æ³„æ¼

**ç°è±¡**ï¼šå†…å­˜æŒç»­å¢é•¿ï¼ŒFull GC é¢‘ç¹

**åŸå› **ï¼šThreadLocal çš„ key æ˜¯å¼±å¼•ç”¨ï¼ŒGC å value ä»å­˜åœ¨

**æ•™è®­**ï¼š
```java
try {
    UserInfoContext.set(user);
    // ä¸šåŠ¡é€»è¾‘
} finally {
    UserInfoContext.remove();  // å¿…é¡» remove
}
```

---

### å‘3ï¼šCompletableFuture å¼‚å¸¸è¢«å

**ç°è±¡**ï¼šä»»åŠ¡æ‰§è¡Œå¤±è´¥ä½†æ²¡æœ‰æ—¥å¿—

**åŸå› **ï¼šCompletableFuture é»˜è®¤åæ‰å¼‚å¸¸

**æ•™è®­**ï¼š
```java
CompletableFuture.supplyAsync(() -> {
    // ä¸šåŠ¡é€»è¾‘
}, executor)
.exceptionally(ex -> {
    log.error("Error", ex);  // å¿…é¡»å¤„ç†å¼‚å¸¸
    return null;
});
```

---

### å‘4ï¼šçº¿ç¨‹æ± æ²¡æœ‰å‘½å

**ç°è±¡**ï¼šçº¿ç¨‹ dump çœ‹ä¸å‡ºå“ªä¸ªä¸šåŠ¡

**åŸå› **ï¼šé»˜è®¤çº¿ç¨‹å `pool-1-thread-1`

**æ•™è®­**ï¼š
```java
executor.setThreadNamePrefix("clueExecutor-");
```

---

### å‘5ï¼š@Async æ²¡æœ‰æŒ‡å®šçº¿ç¨‹æ± 

**ç°è±¡**ï¼šæ‰€æœ‰å¼‚æ­¥ä»»åŠ¡å…±ç”¨é»˜è®¤çº¿ç¨‹æ± ï¼Œäº’ç›¸å½±å“

**åŸå› **ï¼š`@Async` é»˜è®¤ä½¿ç”¨ `SimpleAsyncTaskExecutor`

**æ•™è®­**ï¼š
```java
@Async("clueExecutor")  // å¿…é¡»æŒ‡å®šçº¿ç¨‹æ± 
public void onApplicationEvent(AgentClueCreateEvent event) {}
```

---

## ä¸ƒã€é¢è¯•é«˜é¢‘é€Ÿè®°

> ä¸å†é‡å¤è´´å¤§æ®µä»£ç ï¼Œåªä¿ç•™**æ ‡å‡†å›ç­”æ¨¡æ¿ + å¾€ä¸Šç¿»å°±èƒ½çœ‹åˆ°çš„ç»†èŠ‚å…¥å£**ã€‚

### 7.1 çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹

- æ ‡å‡†å›ç­”ï¼š**æäº¤ä»»åŠ¡ â†’ å…ˆç”¨æ ¸å¿ƒçº¿ç¨‹ â†’ å†è¿›é˜Ÿåˆ— â†’ å†æ‰©åˆ°æœ€å¤§çº¿ç¨‹æ•° â†’ æœ€åèµ°æ‹’ç»ç­–ç•¥**ã€‚
- å…³é”®ç‚¹ï¼š
  - å…ˆ corePoolSizeï¼Œå† workQueueï¼Œå† maximumPoolSizeï¼Œæœ€å RejectedExecutionHandlerã€‚
  - èƒ½è¯´æ¸…è¿™ 4 æ­¥ï¼Œå†è¡¥ä¸€å¥ã€Œå…·ä½“è§ä¸Šæ–‡ 1.1 çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ã€ï¼Œé¢è¯•å®˜å°±é—­å˜´äº†ã€‚

### 7.2 çº¿ç¨‹æ± å‚æ•°è®¾ç½®

- æ ‡å‡†å›ç­”ï¼š
  - **CPU å¯†é›†**ï¼šæ ¸å¿ƒ = æœ€å¤§ = N+1ï¼Œé˜Ÿåˆ—å°ä¸€ç‚¹ï¼ˆ~1000ï¼‰ã€‚
  - **IO å¯†é›†**ï¼šæ ¸å¿ƒ â‰ˆ 2Nï¼Œæœ€å¤§ 2N~4Nï¼Œé˜Ÿåˆ—å¯ä»¥å¤§ï¼ˆ10 ä¸‡çº§ï¼‰ã€‚
  - **æ··åˆå‹**ï¼šæˆ‘ä»¬é¡¹ç›®é‡Œç›´æ¥ç”¨ **8N / 16N + ä¸­ç­‰é˜Ÿåˆ—** åšé€šç”¨çº¿ç¨‹æ± ã€‚
- å…³é”®ç‚¹ï¼šè¯´å‡ºå…¬å¼ **`N Ã— (1 + WT/ST)`**ï¼Œå†ç»“åˆè‡ªå·±é¡¹ç›®çš„çº¿ç¨‹æ± å‚æ•°ï¼Œå°±æ˜¯åŠ åˆ†é¡¹ã€‚

### 7.3 çº¿ç¨‹å®‰å…¨æ–¹æ¡ˆ

- æ ‡å‡†å›ç­”ï¼š
  - ç®€å•åŒæ­¥ï¼š`synchronized`ã€‚
  - éœ€è¦ä¸­æ–­/è¶…æ—¶/å…¬å¹³ï¼š`ReentrantLock`ã€‚
  - é«˜å¹¶å‘ Mapï¼š`ConcurrentHashMap`ã€‚
  - è®¡æ•°å™¨ï¼š`AtomicInteger`ã€‚
  - çº¿ç¨‹éš”ç¦»ä¸Šä¸‹æ–‡ï¼š`ThreadLocal / TransmittableThreadLocal`ã€‚
- å…³é”®ç‚¹ï¼šåˆ«èƒŒ API åå­—ï¼Œ**ç”¨ä½ é¡¹ç›®é‡Œçš„çœŸå®åœºæ™¯å»ä¸¾ä¾‹**ï¼ˆæ¯”å¦‚ Binlog ç¼“å­˜ã€ç”¨æˆ·ä¸Šä¸‹æ–‡ï¼‰ã€‚

### 7.4 CompletableFuture å¼‚å¸¸å¤„ç†

- æ ‡å‡†å›ç­”ï¼š
  - `exceptionally`ï¼šå¼‚å¸¸æ—¶ç»™ä¸€ä¸ªé»˜è®¤å€¼ï¼Œ**ä¼šæ”¹ç»“æœ**ã€‚
  - `handle`ï¼šæˆåŠŸ/å¤±è´¥éƒ½èµ°ï¼Œ**ç»Ÿä¸€æ”¶å£**ï¼Œä¹Ÿä¼šæ”¹ç»“æœã€‚
  - `whenComplete`ï¼šåªæ˜¯åšä¸ªè®°å½•ï¼Œ**ä¸æ”¹ç»“æœ**ã€‚
- ä¸€å¥è¯ï¼š**â€œexceptionally/handle æ”¹ç»“æœï¼ŒwhenComplete ä¸æ”¹ç»“æœâ€**ï¼Œç„¶åé¡ºæ‰‹è¡¥ä¸€å¥ã€Œæˆ‘ä»¬çº¿ä¸Šæ‰€æœ‰å¼‚æ­¥éƒ½å¿…é¡»åŠ å¼‚å¸¸å¤„ç†ã€ï¼Œå°±å¤Ÿäº†ã€‚

### 7.5 ç”Ÿäº§è€…-æ¶ˆè´¹è€…

- æ ‡å‡†å›ç­”ï¼š**ç”¨ `BlockingQueue`ï¼Œç”Ÿäº§è€… `put`ï¼Œæ¶ˆè´¹è€… `take`ï¼Œé˜Ÿåˆ—æ»¡/ç©ºæ—¶è‡ªåŠ¨é˜»å¡**ã€‚
- å…³é”®ç‚¹ï¼š
  - è¯´æ¸…æ¥šã€Œè§£è€¦ + èƒŒå‹ + é˜»å¡ç­‰å¾…ã€ï¼Œåˆ«åœ¨äººä¸ºé€ è½®å­ä¸Šæµªè´¹æ—¶é—´ã€‚
  - çœŸæ­£çš„å®ç°çœ‹ä¸Šæ–‡é˜Ÿåˆ—å’Œçº¿ç¨‹æ± é‚£å‡ èŠ‚ï¼Œæ¯”é¢è¯•å®˜å£å—¨é è°±å¤šäº†ã€‚

### 7.6 å•ä¾‹æ¨¡å¼

- æ ‡å‡†å›ç­”ï¼š**é™æ€å†…éƒ¨ç±»å•ä¾‹**ã€‚
  - ç±»åŠ è½½æ—¶åˆå§‹åŒ–ï¼ŒJVM ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚
  - åªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ `getInstance()` æ‰åŠ è½½å†…éƒ¨ç±»ï¼Œå¤©ç„¶æ‡’åŠ è½½ã€‚
- ä¸€å¥è¯æ¨¡æ¿ï¼š
  > â€œæˆ‘ä»¬å®é™…é¡¹ç›®é‡Œå¦‚æœè¦å†™å•ä¾‹ï¼Œä¼šç”¨é™æ€å†…éƒ¨ç±»è¿™ç§å†™æ³•ï¼Œæ—¢çº¿ç¨‹å®‰å…¨åˆä¸ç”¨åŠ é”ï¼ŒJVM å¸®æˆ‘ä»¬ä¿è¯äº†åˆå§‹åŒ–çš„å¯è§æ€§å’ŒåŸå­æ€§ã€‚â€

---

## å…«ã€æ€»ç»“ä¸æœ€ä½³å®è·µ

### 8.1 é¡¹ç›®æ ¸å¿ƒäº®ç‚¹

| äº®ç‚¹ | æŠ€æœ¯æ–¹æ¡ˆ | æ€§èƒ½æå‡ |
|------|---------|---------|
| **çº¿ç¨‹æ± åŠ¨æ€æ‰©å®¹** | ç›‘æ§æ´»è·ƒåº¦ + è‡ªåŠ¨è°ƒæ•´æ ¸å¿ƒçº¿ç¨‹æ•° | é«˜å³°æœŸååé‡æå‡2å€ |
| **å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–** | CompletableFuture + ParallelExecutorUtils | 5ç§’ â†’ 1ç§’ï¼ˆ5å€ï¼‰ |
| **ä¸Šä¸‹æ–‡ä¼ é€’** | TransmittableThreadLocal + TtlExecutors | è§£å†³å¼‚æ­¥ä»»åŠ¡ä¸Šä¸‹æ–‡ä¸¢å¤± |
| **å¤§æ•°æ®é‡åˆ†æ²»** | ForkJoinPool + Lists.partition | 10ä¸‡æ¡æ•°æ®é¿å…OOM |

---

### 8.2 æœ€ä½³å®è·µæ¸…å•

**çº¿ç¨‹æ± é…ç½®**ï¼š
- âœ… æ‰‹åŠ¨åˆ›å»º `ThreadPoolExecutor`ï¼Œç¦æ­¢ä½¿ç”¨ `Executors`
- âœ… æ˜ç¡®æŒ‡å®šé˜Ÿåˆ—å®¹é‡
- âœ… è®¾ç½®çº¿ç¨‹åå‰ç¼€ï¼ˆ`setThreadNamePrefix`ï¼‰
- âœ… é€‰æ‹©åˆé€‚çš„æ‹’ç»ç­–ç•¥
- âœ… æ ¹æ®ä»»åŠ¡ç±»å‹è®¾ç½®çº¿ç¨‹æ•°ï¼ˆCPUå¯†é›†ï¼šN+1ï¼ŒIOå¯†é›†ï¼š2Nï¼‰
- âœ… ä½¿ç”¨ `TtlExecutors` åŒ…è£…çº¿ç¨‹æ± 

**å¼‚æ­¥ç¼–ç¨‹**ï¼š
- âœ… CompletableFuture å¹¶è¡ŒæŸ¥è¯¢
- âœ… `@Async` æŒ‡å®šçº¿ç¨‹æ± 
- âœ… å¼‚å¸¸å¤„ç†ï¼ˆ`exceptionally`ï¼‰
- âœ… æ‰¹é‡å¤„ç†ï¼ˆ`Lists.partition`ï¼‰
- âœ… åˆ†æ²»è®¡ç®—ï¼ˆ`ForkJoinPool`ï¼‰

**çº¿ç¨‹å®‰å…¨**ï¼š
- âœ… ThreadLocal ä½¿ç”¨åå¿…é¡» `remove()`
- âœ… ä½¿ç”¨ `TransmittableThreadLocal` ä¼ é€’ä¸Šä¸‹æ–‡
- âœ… é«˜å¹¶å‘åœºæ™¯ä½¿ç”¨ `ConcurrentHashMap`
- âœ… è®¡æ•°å™¨ä½¿ç”¨ `AtomicInteger`
- âœ… é¿å…å…±äº«å¯å˜çŠ¶æ€

---

### 8.3 æ€§èƒ½ä¼˜åŒ–æ•°æ®æ±‡æ€»

| ä¼˜åŒ–é¡¹ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å€æ•° |
|--------|--------|--------|---------|
| çº¿ç´¢è¯¦æƒ…æŸ¥è¯¢ | 5ç§’ | 1ç§’ | **5å€** |
| å¤§æ•°æ®é‡å¤„ç† | OOM | æ­£å¸¸ | - |
| çº¿ç¨‹æ± ååé‡ | å›ºå®š | åŠ¨æ€æ‰©å®¹ | **2å€** |

---

## ç»“è¯­

æœ¬æ–‡æ¡£åŸºäº **adp-agent-clue-service** é¡¹ç›®çš„çœŸå®å®è·µï¼Œæ€»ç»“äº† Java å¤šçº¿ç¨‹ç¼–ç¨‹çš„æ ¸å¿ƒçŸ¥è¯†ç‚¹å’Œæœ€ä½³å®è·µã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
1. **çº¿ç¨‹æ± **ï¼šæ‰‹åŠ¨åˆ›å»ºï¼Œæ˜ç¡®å‚æ•°ï¼ŒåŠ¨æ€æ‰©å®¹
2. **å¹¶å‘å·¥å…·**ï¼šCompletableFutureã€ForkJoinPoolã€TransmittableThreadLocal
3. **çº¿ç¨‹å®‰å…¨**ï¼šConcurrentHashMapã€AtomicIntegerã€ThreadLocal
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¹¶è¡ŒæŸ¥è¯¢ã€æ‰¹é‡å¤„ç†ã€å¼‚æ­¥è§£è€¦

**è¡€æ³ªæ•™è®­**ï¼š
1. ç¦æ­¢ä½¿ç”¨ `Executors` åˆ›å»ºçº¿ç¨‹æ± 
2. ThreadLocal ä½¿ç”¨åå¿…é¡» remove
3. CompletableFuture å¿…é¡»å¤„ç†å¼‚å¸¸
4. @Async å¿…é¡»æŒ‡å®šçº¿ç¨‹æ± 
5. çº¿ç¨‹æ± å¿…é¡»å‘½å

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.0
**æœ€åæ›´æ–°ï¼š** 2025-01-XX
**ä½œè€…ï¼š** adp-agent-clue-service å›¢é˜Ÿ

